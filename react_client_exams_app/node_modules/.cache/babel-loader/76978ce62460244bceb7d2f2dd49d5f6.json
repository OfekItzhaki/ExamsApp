{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isYargsInstance = exports.rebase = exports.Yargs = void 0;\n\nconst command_1 = require(\"./command\");\n\nconst common_types_1 = require(\"./common-types\");\n\nconst yerror_1 = require(\"./yerror\");\n\nconst usage_1 = require(\"./usage\");\n\nconst argsert_1 = require(\"./argsert\");\n\nconst fs = require(\"fs\");\n\nconst completion_1 = require(\"./completion\");\n\nconst path = require(\"path\");\n\nconst validation_1 = require(\"./validation\");\n\nconst obj_filter_1 = require(\"./obj-filter\");\n\nconst apply_extends_1 = require(\"./apply-extends\");\n\nconst middleware_1 = require(\"./middleware\");\n\nconst processArgv = require(\"./process-argv\");\n\nconst is_promise_1 = require(\"./is-promise\");\n\nconst Parser = require(\"yargs-parser\");\n\nconst y18nFactory = require(\"y18n\");\n\nconst setBlocking = require(\"set-blocking\");\n\nconst findUp = require(\"find-up\");\n\nconst requireMainFilename = require(\"require-main-filename\");\n\nfunction Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {\n  const self = {};\n  let command;\n  let completion = null;\n  let groups = {};\n  const globalMiddleware = [];\n  let output = '';\n  const preservedGroups = {};\n  let usage;\n  let validation;\n  let handlerFinishCommand = null;\n  const y18n = y18nFactory({\n    directory: path.resolve(__dirname, '../../locales'),\n    updateFiles: false\n  });\n  self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);\n\n  self.scriptName = function (scriptName) {\n    self.customScriptName = true;\n    self.$0 = scriptName;\n    return self;\n  }; // ignore the node bin, specify this in your\n  // bin file with #!/usr/bin/env node\n\n\n  let default$0;\n\n  if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n    default$0 = process.argv.slice(1, 2);\n  } else {\n    default$0 = process.argv.slice(0, 1);\n  }\n\n  self.$0 = default$0.map(x => {\n    const b = rebase(cwd, x);\n    return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n  }).join(' ').trim();\n\n  if (process.env._ !== undefined && processArgv.getProcessArgvBin() === process.env._) {\n    self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, '');\n  } // use context object to keep track of resets, subcommand execution, etc\n  // submodules should modify and check the state of context as necessary\n\n\n  const context = {\n    resets: -1,\n    commands: [],\n    fullCommands: [],\n    files: []\n  };\n\n  self.getContext = () => context; // puts yargs back into an initial state. any keys\n  // that have been set to \"global\" will not be reset\n  // by this action.\n\n\n  let options;\n\n  self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n    context.resets++;\n    options = options || {}; // put yargs back into an initial state, this\n    // logic is used to build a nested command\n    // hierarchy.\n\n    const tmpOptions = {};\n    tmpOptions.local = options.local ? options.local : [];\n    tmpOptions.configObjects = options.configObjects ? options.configObjects : []; // if a key has been explicitly set as local,\n    // we should reset it before passing options to command.\n\n    const localLookup = {};\n    tmpOptions.local.forEach(l => {\n      localLookup[l] = true;\n      (aliases[l] || []).forEach(a => {\n        localLookup[a] = true;\n      });\n    }); // add all groups not set to local to preserved groups\n\n    Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n      const keys = groups[groupName].filter(key => !(key in localLookup));\n\n      if (keys.length > 0) {\n        acc[groupName] = keys;\n      }\n\n      return acc;\n    }, {})); // groups can now be reset\n\n    groups = {};\n    const arrayOptions = ['array', 'boolean', 'string', 'skipValidation', 'count', 'normalize', 'number', 'hiddenOptions'];\n    const objectOptions = ['narg', 'key', 'alias', 'default', 'defaultDescription', 'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce', 'deprecatedOptions'];\n    arrayOptions.forEach(k => {\n      tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n    });\n    objectOptions.forEach(k => {\n      tmpOptions[k] = obj_filter_1.objFilter(options[k], k => !localLookup[k]);\n    });\n    tmpOptions.envPrefix = options.envPrefix;\n    options = tmpOptions; // if this is the first time being executed, create\n    // instances of all our helpers -- otherwise just reset.\n\n    usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);\n    validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);\n    command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);\n    if (!completion) completion = completion_1.completion(self, usage, command);\n    completionCommand = null;\n    output = '';\n    exitError = null;\n    hasOutput = false;\n    self.parsed = false;\n    return self;\n  };\n\n  self.resetOptions(); // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n\n  const frozens = [];\n\n  function freeze() {\n    frozens.push({\n      options,\n      configObjects: options.configObjects.slice(0),\n      exitProcess,\n      groups,\n      strict,\n      strictCommands,\n      completionCommand,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    });\n    usage.freeze();\n    validation.freeze();\n    command.freeze();\n  }\n\n  function unfreeze() {\n    const frozen = frozens.pop();\n    common_types_1.assertNotStrictEqual(frozen, undefined);\n    let configObjects;\n    ({\n      options,\n      configObjects,\n      exitProcess,\n      groups,\n      output,\n      exitError,\n      hasOutput,\n      parsed: self.parsed,\n      strict,\n      strictCommands,\n      completionCommand,\n      parseFn,\n      parseContext,\n      handlerFinishCommand\n    } = frozen);\n    options.configObjects = configObjects;\n    usage.unfreeze();\n    validation.unfreeze();\n    command.unfreeze();\n  }\n\n  self.boolean = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('boolean', keys);\n    return self;\n  };\n\n  self.array = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('array', keys);\n    return self;\n  };\n\n  self.number = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('number', keys);\n    return self;\n  };\n\n  self.normalize = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('normalize', keys);\n    return self;\n  };\n\n  self.count = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('count', keys);\n    return self;\n  };\n\n  self.string = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('string', keys);\n    return self;\n  };\n\n  self.requiresArg = function (keys) {\n    // the 2nd paramter [number] in the argsert the assertion is mandatory\n    // as populateParserHintSingleValueDictionary recursively calls requiresArg\n    // with Nan as a 2nd parameter, although we ignore it\n    argsert_1.argsert('<array|string|object> [number]', [keys], arguments.length); // If someone configures nargs at the same time as requiresArg,\n    // nargs should take precedent,\n    // see: https://github.com/yargs/yargs/pull/1572\n    // TODO: make this work with aliases, using a check similar to\n    // checkAllAliases() in yargs-parser.\n\n    if (typeof keys === 'string' && options.narg[keys]) {\n      return self;\n    } else {\n      populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n    }\n\n    return self;\n  };\n\n  self.skipValidation = function (keys) {\n    argsert_1.argsert('<array|string>', [keys], arguments.length);\n    populateParserHintArray('skipValidation', keys);\n    return self;\n  };\n\n  function populateParserHintArray(type, keys) {\n    keys = [].concat(keys);\n    keys.forEach(key => {\n      key = sanitizeKey(key);\n      options[type].push(key);\n    });\n  }\n\n  self.nargs = function (key, value) {\n    argsert_1.argsert('<string|object|array> [number]', [key, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n    return self;\n  };\n\n  self.choices = function (key, value) {\n    argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n    return self;\n  };\n\n  self.alias = function (key, value) {\n    argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n    populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n    return self;\n  }; // TODO: actually deprecate self.defaults.\n\n\n  self.default = self.defaults = function (key, value, defaultDescription) {\n    argsert_1.argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n\n    if (defaultDescription) {\n      common_types_1.assertSingleKey(key);\n      options.defaultDescription[key] = defaultDescription;\n    }\n\n    if (typeof value === 'function') {\n      common_types_1.assertSingleKey(key);\n      if (!options.defaultDescription[key]) options.defaultDescription[key] = usage.functionDescription(value);\n      value = value.call();\n    }\n\n    populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n    return self;\n  };\n\n  self.describe = function (key, desc) {\n    argsert_1.argsert('<object|string|array> [string]', [key, desc], arguments.length);\n    setKey(key, true);\n    usage.describe(key, desc);\n    return self;\n  };\n\n  function setKey(key, set) {\n    populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n    return self;\n  }\n\n  function demandOption(keys, msg) {\n    argsert_1.argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n    populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n    return self;\n  }\n\n  self.demandOption = demandOption;\n\n  self.coerce = function (keys, value) {\n    argsert_1.argsert('<object|string|array> [function]', [keys, value], arguments.length);\n    populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n    return self;\n  };\n\n  function populateParserHintSingleValueDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = value;\n    });\n  }\n\n  function populateParserHintArrayDictionary(builder, type, key, value) {\n    populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n      options[type][key] = (options[type][key] || []).concat(value);\n    });\n  }\n\n  function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n    if (Array.isArray(key)) {\n      // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n      key.forEach(k => {\n        builder(k, value);\n      });\n    } else if ((key => typeof key === 'object')(key)) {\n      // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n      for (const k of common_types_1.objectKeys(key)) {\n        builder(k, key[k]);\n      }\n    } else {\n      singleKeyHandler(type, sanitizeKey(key), value);\n    }\n  }\n\n  function sanitizeKey(key) {\n    if (key === '__proto__') return '___proto___';\n    return key;\n  }\n\n  function deleteFromParserHintObject(optionKey) {\n    // delete from all parsing hints:\n    // boolean, array, key, alias, etc.\n    common_types_1.objectKeys(options).forEach(hintKey => {\n      // configObjects is not a parsing hint array\n      if ((key => key === 'configObjects')(hintKey)) return;\n      const hint = options[hintKey];\n\n      if (Array.isArray(hint)) {\n        if (~hint.indexOf(optionKey)) hint.splice(hint.indexOf(optionKey), 1);\n      } else if (typeof hint === 'object') {\n        delete hint[optionKey];\n      }\n    }); // now delete the description from usage.js.\n\n    delete usage.getDescriptions()[optionKey];\n  }\n\n  self.config = function config(key = 'config', msg, parseFn) {\n    argsert_1.argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length); // allow a config object to be provided directly.\n\n    if (typeof key === 'object' && !Array.isArray(key)) {\n      key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config']);\n      options.configObjects = (options.configObjects || []).concat(key);\n      return self;\n    } // allow for a custom parsing function.\n\n\n    if (typeof msg === 'function') {\n      parseFn = msg;\n      msg = undefined;\n    }\n\n    self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n    (Array.isArray(key) ? key : [key]).forEach(k => {\n      options.config[k] = parseFn || true;\n    });\n    return self;\n  };\n\n  self.example = function (cmd, description) {\n    argsert_1.argsert('<string|array> [string]', [cmd, description], arguments.length);\n\n    if (Array.isArray(cmd)) {\n      cmd.forEach(exampleParams => self.example(...exampleParams));\n    } else {\n      usage.example(cmd, description);\n    }\n\n    return self;\n  };\n\n  self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n    argsert_1.argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n    command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n    return self;\n  };\n\n  self.commandDir = function (dir, opts) {\n    argsert_1.argsert('<string> [object]', [dir, opts], arguments.length);\n    const req = parentRequire || require;\n    command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n    return self;\n  }; // TODO: deprecate self.demand in favor of\n  // .demandCommand() .demandOption().\n\n\n  self.demand = self.required = self.require = function demand(keys, max, msg) {\n    // you can optionally provide a 'max' key,\n    // which will raise an exception if too many '_'\n    // options are provided.\n    if (Array.isArray(max)) {\n      max.forEach(key => {\n        common_types_1.assertNotStrictEqual(msg, true);\n        demandOption(key, msg);\n      });\n      max = Infinity;\n    } else if (typeof max !== 'number') {\n      msg = max;\n      max = Infinity;\n    }\n\n    if (typeof keys === 'number') {\n      common_types_1.assertNotStrictEqual(msg, true);\n      self.demandCommand(keys, max, msg, msg);\n    } else if (Array.isArray(keys)) {\n      keys.forEach(key => {\n        common_types_1.assertNotStrictEqual(msg, true);\n        demandOption(key, msg);\n      });\n    } else {\n      if (typeof msg === 'string') {\n        demandOption(keys, msg);\n      } else if (msg === true || typeof msg === 'undefined') {\n        demandOption(keys);\n      }\n    }\n\n    return self;\n  };\n\n  self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n    argsert_1.argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n\n    if (typeof max !== 'number') {\n      minMsg = max;\n      max = Infinity;\n    }\n\n    self.global('_', false);\n    options.demandedCommands._ = {\n      min,\n      max,\n      minMsg,\n      maxMsg\n    };\n    return self;\n  };\n\n  self.getDemandedOptions = () => {\n    argsert_1.argsert([], 0);\n    return options.demandedOptions;\n  };\n\n  self.getDemandedCommands = () => {\n    argsert_1.argsert([], 0);\n    return options.demandedCommands;\n  };\n\n  self.deprecateOption = function deprecateOption(option, message) {\n    argsert_1.argsert('<string> [string|boolean]', [option, message], arguments.length);\n    options.deprecatedOptions[option] = message;\n    return self;\n  };\n\n  self.getDeprecatedOptions = () => {\n    argsert_1.argsert([], 0);\n    return options.deprecatedOptions;\n  };\n\n  self.implies = function (key, value) {\n    argsert_1.argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n    validation.implies(key, value);\n    return self;\n  };\n\n  self.conflicts = function (key1, key2) {\n    argsert_1.argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n    validation.conflicts(key1, key2);\n    return self;\n  };\n\n  self.usage = function (msg, description, builder, handler) {\n    argsert_1.argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n\n    if (description !== undefined) {\n      common_types_1.assertNotStrictEqual(msg, null); // .usage() can be used as an alias for defining\n      // a default command.\n\n      if ((msg || '').match(/^\\$0( |$)/)) {\n        return self.command(msg, description, builder, handler);\n      } else {\n        throw new yerror_1.YError('.usage() description must start with $0 if being used as alias for .command()');\n      }\n    } else {\n      usage.usage(msg);\n      return self;\n    }\n  };\n\n  self.epilogue = self.epilog = function (msg) {\n    argsert_1.argsert('<string>', [msg], arguments.length);\n    usage.epilog(msg);\n    return self;\n  };\n\n  self.fail = function (f) {\n    argsert_1.argsert('<function>', [f], arguments.length);\n    usage.failFn(f);\n    return self;\n  };\n\n  self.onFinishCommand = function (f) {\n    argsert_1.argsert('<function>', [f], arguments.length);\n    handlerFinishCommand = f;\n    return self;\n  };\n\n  self.getHandlerFinishCommand = () => handlerFinishCommand;\n\n  self.check = function (f, _global) {\n    argsert_1.argsert('<function> [boolean]', [f, _global], arguments.length);\n    validation.check(f, _global !== false);\n    return self;\n  };\n\n  self.global = function global(globals, global) {\n    argsert_1.argsert('<string|array> [boolean]', [globals, global], arguments.length);\n    globals = [].concat(globals);\n\n    if (global !== false) {\n      options.local = options.local.filter(l => globals.indexOf(l) === -1);\n    } else {\n      globals.forEach(g => {\n        if (options.local.indexOf(g) === -1) options.local.push(g);\n      });\n    }\n\n    return self;\n  };\n\n  self.pkgConf = function pkgConf(key, rootPath) {\n    argsert_1.argsert('<string> [string]', [key, rootPath], arguments.length);\n    let conf = null; // prefer cwd to require-main-filename in this method\n    // since we're looking for e.g. \"nyc\" config in nyc consumer\n    // rather than \"yargs\" config in nyc (where nyc is the main filename)\n\n    const obj = pkgUp(rootPath || cwd); // If an object exists in the key, add it to options.configObjects\n\n    if (obj[key] && typeof obj[key] === 'object') {\n      conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config']);\n      options.configObjects = (options.configObjects || []).concat(conf);\n    }\n\n    return self;\n  };\n\n  const pkgs = {};\n\n  function pkgUp(rootPath) {\n    const npath = rootPath || '*';\n    if (pkgs[npath]) return pkgs[npath];\n    let obj = {};\n\n    try {\n      let startDir = rootPath || requireMainFilename(parentRequire); // When called in an environment that lacks require.main.filename, such as a jest test runner,\n      // startDir is already process.cwd(), and should not be shortened.\n      // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n\n      if (!rootPath && path.extname(startDir)) {\n        startDir = path.dirname(startDir);\n      }\n\n      const pkgJsonPath = findUp.sync('package.json', {\n        cwd: startDir\n      });\n      common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);\n      obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());\n    } catch (noop) {}\n\n    pkgs[npath] = obj || {};\n    return pkgs[npath];\n  }\n\n  let parseFn = null;\n  let parseContext = null;\n\n  self.parse = function parse(args, shortCircuit, _parseFn) {\n    argsert_1.argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n    freeze();\n\n    if (typeof args === 'undefined') {\n      const argv = self._parseArgs(processArgs);\n\n      const tmpParsed = self.parsed;\n      unfreeze(); // TODO: remove this compatibility hack when we release yargs@15.x:\n\n      self.parsed = tmpParsed;\n      return argv;\n    } // a context object can optionally be provided, this allows\n    // additional information to be passed to a command handler.\n\n\n    if (typeof shortCircuit === 'object') {\n      parseContext = shortCircuit;\n      shortCircuit = _parseFn;\n    } // by providing a function as a second argument to\n    // parse you can capture output that would otherwise\n    // default to printing to stdout/stderr.\n\n\n    if (typeof shortCircuit === 'function') {\n      parseFn = shortCircuit;\n      shortCircuit = false;\n    } // completion short-circuits the parsing process,\n    // skipping validation, etc.\n\n\n    if (!shortCircuit) processArgs = args;\n    if (parseFn) exitProcess = false;\n\n    const parsed = self._parseArgs(args, !!shortCircuit);\n\n    completion.setParsed(self.parsed);\n    if (parseFn) parseFn(exitError, parsed, output);\n    unfreeze();\n    return parsed;\n  };\n\n  self._getParseContext = () => parseContext || {};\n\n  self._hasParseCallback = () => !!parseFn;\n\n  self.option = self.options = function option(key, opt) {\n    argsert_1.argsert('<string|object> [object]', [key, opt], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.options(k, key[k]);\n      });\n    } else {\n      if (typeof opt !== 'object') {\n        opt = {};\n      }\n\n      options.key[key] = true; // track manually set keys.\n\n      if (opt.alias) self.alias(key, opt.alias);\n      const deprecate = opt.deprecate || opt.deprecated;\n\n      if (deprecate) {\n        self.deprecateOption(key, deprecate);\n      }\n\n      const demand = opt.demand || opt.required || opt.require; // A required option can be specified via \"demand: true\".\n\n      if (demand) {\n        self.demand(key, demand);\n      }\n\n      if (opt.demandOption) {\n        self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n      }\n\n      if (opt.conflicts) {\n        self.conflicts(key, opt.conflicts);\n      }\n\n      if ('default' in opt) {\n        self.default(key, opt.default);\n      }\n\n      if (opt.implies !== undefined) {\n        self.implies(key, opt.implies);\n      }\n\n      if (opt.nargs !== undefined) {\n        self.nargs(key, opt.nargs);\n      }\n\n      if (opt.config) {\n        self.config(key, opt.configParser);\n      }\n\n      if (opt.normalize) {\n        self.normalize(key);\n      }\n\n      if (opt.choices) {\n        self.choices(key, opt.choices);\n      }\n\n      if (opt.coerce) {\n        self.coerce(key, opt.coerce);\n      }\n\n      if (opt.group) {\n        self.group(key, opt.group);\n      }\n\n      if (opt.boolean || opt.type === 'boolean') {\n        self.boolean(key);\n        if (opt.alias) self.boolean(opt.alias);\n      }\n\n      if (opt.array || opt.type === 'array') {\n        self.array(key);\n        if (opt.alias) self.array(opt.alias);\n      }\n\n      if (opt.number || opt.type === 'number') {\n        self.number(key);\n        if (opt.alias) self.number(opt.alias);\n      }\n\n      if (opt.string || opt.type === 'string') {\n        self.string(key);\n        if (opt.alias) self.string(opt.alias);\n      }\n\n      if (opt.count || opt.type === 'count') {\n        self.count(key);\n      }\n\n      if (typeof opt.global === 'boolean') {\n        self.global(key, opt.global);\n      }\n\n      if (opt.defaultDescription) {\n        options.defaultDescription[key] = opt.defaultDescription;\n      }\n\n      if (opt.skipValidation) {\n        self.skipValidation(key);\n      }\n\n      const desc = opt.describe || opt.description || opt.desc;\n      self.describe(key, desc);\n\n      if (opt.hidden) {\n        self.hide(key);\n      }\n\n      if (opt.requiresArg) {\n        self.requiresArg(key);\n      }\n    }\n\n    return self;\n  };\n\n  self.getOptions = () => options;\n\n  self.positional = function (key, opts) {\n    argsert_1.argsert('<string> <object>', [key, opts], arguments.length);\n\n    if (context.resets === 0) {\n      throw new yerror_1.YError(\".positional() can only be called in a command's builder function\");\n    } // .positional() only supports a subset of the configuration\n    // options available to .option().\n\n\n    const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize', 'choices', 'conflicts', 'coerce', 'type', 'describe', 'desc', 'description', 'alias'];\n    opts = obj_filter_1.objFilter(opts, (k, v) => {\n      let accept = supportedOpts.indexOf(k) !== -1; // type can be one of string|number|boolean.\n\n      if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1) accept = false;\n      return accept;\n    }); // copy over any settings that can be inferred from the command string.\n\n    const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n    const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    common_types_1.objectKeys(parseOptions).forEach(pk => {\n      const parseOption = parseOptions[pk];\n\n      if (Array.isArray(parseOption)) {\n        if (parseOption.indexOf(key) !== -1) opts[pk] = true;\n      } else {\n        if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];\n      }\n    });\n    self.group(key, usage.getPositionalGroupName());\n    return self.option(key, opts);\n  };\n\n  self.group = function group(opts, groupName) {\n    argsert_1.argsert('<string|array> <string>', [opts, groupName], arguments.length);\n    const existing = preservedGroups[groupName] || groups[groupName];\n\n    if (preservedGroups[groupName]) {\n      // we now only need to track this group name in groups.\n      delete preservedGroups[groupName];\n    }\n\n    const seen = {};\n    groups[groupName] = (existing || []).concat(opts).filter(key => {\n      if (seen[key]) return false;\n      return seen[key] = true;\n    });\n    return self;\n  }; // combine explicit and preserved groups. explicit groups should be first\n\n\n  self.getGroups = () => Object.assign({}, groups, preservedGroups); // as long as options.envPrefix is not undefined,\n  // parser will apply env vars matching prefix to argv\n\n\n  self.env = function (prefix) {\n    argsert_1.argsert('[string|boolean]', [prefix], arguments.length);\n    if (prefix === false) delete options.envPrefix;else options.envPrefix = prefix || '';\n    return self;\n  };\n\n  self.wrap = function (cols) {\n    argsert_1.argsert('<number|null|undefined>', [cols], arguments.length);\n    usage.wrap(cols);\n    return self;\n  };\n\n  let strict = false;\n\n  self.strict = function (enabled) {\n    argsert_1.argsert('[boolean]', [enabled], arguments.length);\n    strict = enabled !== false;\n    return self;\n  };\n\n  self.getStrict = () => strict;\n\n  let strictCommands = false;\n\n  self.strictCommands = function (enabled) {\n    argsert_1.argsert('[boolean]', [enabled], arguments.length);\n    strictCommands = enabled !== false;\n    return self;\n  };\n\n  self.getStrictCommands = () => strictCommands;\n\n  let parserConfig = {};\n\n  self.parserConfiguration = function parserConfiguration(config) {\n    argsert_1.argsert('<object>', [config], arguments.length);\n    parserConfig = config;\n    return self;\n  };\n\n  self.getParserConfiguration = () => parserConfig;\n\n  self.showHelp = function (level) {\n    argsert_1.argsert('[string|function]', [level], arguments.length);\n    if (!self.parsed) self._parseArgs(processArgs); // run parser, if it has not already been executed.\n\n    if (command.hasDefaultCommand()) {\n      context.resets++; // override the restriction on top-level positoinals.\n\n      command.runDefaultBuilderOn(self);\n    }\n\n    usage.showHelp(level);\n    return self;\n  };\n\n  let versionOpt = null;\n\n  self.version = function version(opt, msg, ver) {\n    const defaultVersionOpt = 'version';\n    argsert_1.argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length); // nuke the key previously configured\n    // to return version #.\n\n    if (versionOpt) {\n      deleteFromParserHintObject(versionOpt);\n      usage.version(undefined);\n      versionOpt = null;\n    }\n\n    if (arguments.length === 0) {\n      ver = guessVersion();\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 1) {\n      if (opt === false) {\n        // disable default 'version' key.\n        return self;\n      }\n\n      ver = opt;\n      opt = defaultVersionOpt;\n    } else if (arguments.length === 2) {\n      ver = msg;\n      msg = undefined;\n    }\n\n    versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n    msg = msg || usage.deferY18nLookup('Show version number');\n    usage.version(ver || undefined);\n    self.boolean(versionOpt);\n    self.describe(versionOpt, msg);\n    return self;\n  };\n\n  function guessVersion() {\n    const obj = pkgUp();\n    return obj.version || 'unknown';\n  }\n\n  let helpOpt = null;\n\n  self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n    const defaultHelpOpt = 'help';\n    argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length); // nuke the key previously configured\n    // to return help.\n\n    if (helpOpt) {\n      deleteFromParserHintObject(helpOpt);\n      helpOpt = null;\n    }\n\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    } // use arguments, fallback to defaults for opt and msg\n\n\n    helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n    self.boolean(helpOpt);\n    self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n    return self;\n  };\n\n  const defaultShowHiddenOpt = 'show-hidden';\n  options.showHiddenOpt = defaultShowHiddenOpt;\n\n  self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n    argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n\n    if (arguments.length === 1) {\n      if (opt === false) return self;\n    }\n\n    const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n    self.boolean(showHiddenOpt);\n    self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n    options.showHiddenOpt = showHiddenOpt;\n    return self;\n  };\n\n  self.hide = function hide(key) {\n    argsert_1.argsert('<string>', [key], arguments.length);\n    options.hiddenOptions.push(key);\n    return self;\n  };\n\n  self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n    argsert_1.argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n    usage.showHelpOnFail(enabled, message);\n    return self;\n  };\n\n  var exitProcess = true;\n\n  self.exitProcess = function (enabled = true) {\n    argsert_1.argsert('[boolean]', [enabled], arguments.length);\n    exitProcess = enabled;\n    return self;\n  };\n\n  self.getExitProcess = () => exitProcess;\n\n  var completionCommand = null;\n\n  self.completion = function (cmd, desc, fn) {\n    argsert_1.argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length); // a function to execute when generating\n    // completions can be provided as the second\n    // or third argument to completion.\n\n    if (typeof desc === 'function') {\n      fn = desc;\n      desc = undefined;\n    } // register the completion command.\n\n\n    completionCommand = cmd || completionCommand || 'completion';\n\n    if (!desc && desc !== false) {\n      desc = 'generate completion script';\n    }\n\n    self.command(completionCommand, desc); // a function can be provided\n\n    if (fn) completion.registerFunction(fn);\n    return self;\n  };\n\n  self.showCompletionScript = function ($0, cmd) {\n    argsert_1.argsert('[string] [string]', [$0, cmd], arguments.length);\n    $0 = $0 || self.$0;\n\n    _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n\n    return self;\n  };\n\n  self.getCompletion = function (args, done) {\n    argsert_1.argsert('<array> <function>', [args, done], arguments.length);\n    completion.getCompletion(args, done);\n  };\n\n  self.locale = function (locale) {\n    argsert_1.argsert('[string]', [locale], arguments.length);\n\n    if (!locale) {\n      guessLocale();\n      return y18n.getLocale();\n    }\n\n    detectLocale = false;\n    y18n.setLocale(locale);\n    return self;\n  };\n\n  self.updateStrings = self.updateLocale = function (obj) {\n    argsert_1.argsert('<object>', [obj], arguments.length);\n    detectLocale = false;\n    y18n.updateLocale(obj);\n    return self;\n  };\n\n  let detectLocale = true;\n\n  self.detectLocale = function (detect) {\n    argsert_1.argsert('<boolean>', [detect], arguments.length);\n    detectLocale = detect;\n    return self;\n  };\n\n  self.getDetectLocale = () => detectLocale;\n\n  var hasOutput = false;\n  var exitError = null; // maybe exit, always capture\n  // context about why we wanted to exit.\n\n  self.exit = (code, err) => {\n    hasOutput = true;\n    exitError = err;\n    if (exitProcess) process.exit(code);\n  }; // we use a custom logger that buffers output,\n  // so that we can print to non-CLIs, e.g., chat-bots.\n\n\n  const _logger = {\n    log(...args) {\n      if (!self._hasParseCallback()) console.log(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    },\n\n    error(...args) {\n      if (!self._hasParseCallback()) console.error(...args);\n      hasOutput = true;\n      if (output.length) output += '\\n';\n      output += args.join(' ');\n    }\n\n  };\n\n  self._getLoggerInstance = () => _logger; // has yargs output an error our help\n  // message in the current execution context.\n\n\n  self._hasOutput = () => hasOutput;\n\n  self._setHasOutput = () => {\n    hasOutput = true;\n  };\n\n  let recommendCommands;\n\n  self.recommendCommands = function (recommend = true) {\n    argsert_1.argsert('[boolean]', [recommend], arguments.length);\n    recommendCommands = recommend;\n    return self;\n  };\n\n  self.getUsageInstance = () => usage;\n\n  self.getValidationInstance = () => validation;\n\n  self.getCommandInstance = () => command;\n\n  self.terminalWidth = () => {\n    argsert_1.argsert([], 0);\n    return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n  };\n\n  Object.defineProperty(self, 'argv', {\n    get: () => self._parseArgs(processArgs),\n    enumerable: true\n  });\n\n  self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n    let skipValidation = !!_calledFromCommand;\n    args = args || processArgs;\n    options.__ = y18n.__;\n    options.configuration = self.getParserConfiguration();\n    const populateDoubleDash = !!options.configuration['populate--'];\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = Parser.detailed(args, Object.assign({}, options, {\n      configuration: config\n    }));\n    let argv = parsed.argv;\n    if (parseContext) argv = Object.assign({}, argv, parseContext);\n    const aliases = parsed.aliases;\n    argv.$0 = self.$0;\n    self.parsed = parsed;\n\n    try {\n      guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n      // while building up the argv object, there\n      // are two passes through the parser. If completion\n      // is being performed short-circuit on the first pass.\n\n      if (shortCircuit) {\n        return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);\n      } // if there's a handler associated with a\n      // command defer processing to it.\n\n\n      if (helpOpt) {\n        // consider any multi-char helpOpt alias as a valid help command\n        // unless all helpOpt aliases are single-char\n        // note that parsed.aliases is a normalized bidirectional map :)\n        const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter(k => k.length > 1); // check if help should trigger and strip it from _.\n\n        if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n          argv._.pop();\n\n          argv[helpOpt] = true;\n        }\n      }\n\n      const handlerKeys = command.getCommands();\n      const requestCompletions = (completion.completionKey in argv);\n      const skipRecommendation = argv[helpOpt] || requestCompletions;\n      const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n\n      if (argv._.length) {\n        if (handlerKeys.length) {\n          let firstUnknownCommand;\n\n          for (let i = commandIndex || 0, cmd; argv._[i] !== undefined; i++) {\n            cmd = String(argv._[i]);\n\n            if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n              // commands are executed using a recursive algorithm that executes\n              // the deepest command first; we keep track of the position in the\n              // argv._ array that is currently being executed.\n              const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n              return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n            } else if (!firstUnknownCommand && cmd !== completionCommand) {\n              firstUnknownCommand = cmd;\n              break;\n            }\n          } // run the default command, if defined\n\n\n          if (command.hasDefaultCommand() && !skipDefaultCommand) {\n            const innerArgv = command.runCommand(null, self, parsed);\n            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n          } // recommend a command if recommendCommands() has\n          // been enabled, and no commands were found to execute\n\n\n          if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n            validation.recommendCommands(firstUnknownCommand, handlerKeys);\n          }\n        } // generate a completion script for adding to ~/.bashrc.\n\n\n        if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n          if (exitProcess) setBlocking(true);\n          self.showCompletionScript();\n          self.exit(0);\n        }\n      } else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n        const innerArgv = command.runCommand(null, self, parsed);\n        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n      } // we must run completions first, a user might\n      // want to complete the --help or --version option.\n\n\n      if (requestCompletions) {\n        if (exitProcess) setBlocking(true); // we allow for asynchronous completions,\n        // e.g., loading in a list of commands from an API.\n\n        args = [].concat(args);\n        const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n        completion.getCompletion(completionArgs, completions => {\n          ;\n          (completions || []).forEach(completion => {\n            _logger.log(completion);\n          });\n          self.exit(0);\n        });\n        return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);\n      } // Handle 'help' and 'version' options\n      // if we haven't already output help!\n\n\n      if (!hasOutput) {\n        Object.keys(argv).forEach(key => {\n          if (key === helpOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            self.showHelp('log');\n            self.exit(0);\n          } else if (key === versionOpt && argv[key]) {\n            if (exitProcess) setBlocking(true);\n            skipValidation = true;\n            usage.showVersion();\n            self.exit(0);\n          }\n        });\n      } // Check if any of the options to skip validation were provided\n\n\n      if (!skipValidation && options.skipValidation.length > 0) {\n        skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n      } // If the help or version options where used and exitProcess is false,\n      // or if explicitly skipped, we won't run validations.\n\n\n      if (!skipValidation) {\n        if (parsed.error) throw new yerror_1.YError(parsed.error.message); // if we're executed via bash completion, don't\n        // bother with validation.\n\n        if (!requestCompletions) {\n          self._runValidation(argv, aliases, {}, parsed.error);\n        }\n      }\n    } catch (err) {\n      if (err instanceof yerror_1.YError) usage.fail(err.message, err);else throw err;\n    }\n\n    return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);\n  }; // to simplify the parsing of positionals in commands,\n  // we temporarily populate '--' rather than _, with arguments\n  // after the '--' directive. After the parse, we copy these back.\n\n\n  self._copyDoubleDash = function (argv) {\n    if (is_promise_1.isPromise(argv) || !argv._ || !argv['--']) return argv;\n\n    argv._.push.apply(argv._, argv['--']); // TODO(bcoe): refactor command parsing such that this delete is not\n    // necessary: https://github.com/yargs/yargs/issues/1482\n\n\n    try {\n      delete argv['--'];\n    } catch (_err) {}\n\n    return argv;\n  };\n\n  self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n    if (parseErrors) throw new yerror_1.YError(parseErrors.message);\n    validation.nonOptionCount(argv);\n    validation.requiredArguments(argv);\n    let failedStrictCommands = false;\n\n    if (strictCommands) {\n      failedStrictCommands = validation.unknownCommands(argv);\n    }\n\n    if (strict && !failedStrictCommands) {\n      validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n    }\n\n    validation.customChecks(argv, aliases);\n    validation.limitedChoices(argv);\n    validation.implications(argv);\n    validation.conflicting(argv);\n  };\n\n  function guessLocale() {\n    if (!detectLocale) return;\n    const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || 'en_US';\n    self.locale(locale.replace(/[.:].*/, ''));\n  } // an app should almost always have --version and --help,\n  // if you *really* want to disable this use .help(false)/.version(false).\n\n\n  self.help();\n  self.version();\n  return self;\n}\n\nexports.Yargs = Yargs; // rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\n\nfunction rebase(base, dir) {\n  return path.relative(base, dir);\n}\n\nexports.rebase = rebase;\n\nfunction isYargsInstance(y) {\n  return !!y && typeof y._parseArgs === 'function';\n}\n\nexports.isYargsInstance = isYargsInstance;","map":{"version":3,"sources":["C:/Users/ofeki/OneDrive/שולחן העבודה/ExamApp design ver/ExamsApp/react_client_exams_app/node_modules/yargs/build/lib/yargs.js"],"names":["Object","defineProperty","exports","value","isYargsInstance","rebase","Yargs","command_1","require","common_types_1","yerror_1","usage_1","argsert_1","fs","completion_1","path","validation_1","obj_filter_1","apply_extends_1","middleware_1","processArgv","is_promise_1","Parser","y18nFactory","setBlocking","findUp","requireMainFilename","processArgs","cwd","process","parentRequire","self","command","completion","groups","globalMiddleware","output","preservedGroups","usage","validation","handlerFinishCommand","y18n","directory","resolve","__dirname","updateFiles","middleware","globalMiddlewareFactory","scriptName","customScriptName","$0","default$0","test","argv","slice","map","x","b","match","length","join","trim","env","_","undefined","getProcessArgvBin","replace","dirname","execPath","context","resets","commands","fullCommands","files","getContext","options","resetOptions","reset","aliases","tmpOptions","local","configObjects","localLookup","forEach","l","a","assign","keys","reduce","acc","groupName","filter","key","arrayOptions","objectOptions","k","objFilter","envPrefix","completionCommand","exitError","hasOutput","parsed","frozens","freeze","push","exitProcess","strict","strictCommands","parseFn","parseContext","unfreeze","frozen","pop","assertNotStrictEqual","boolean","argsert","arguments","populateParserHintArray","array","number","normalize","count","string","requiresArg","narg","populateParserHintSingleValueDictionary","NaN","skipValidation","type","concat","sanitizeKey","nargs","choices","populateParserHintArrayDictionary","alias","default","defaults","defaultDescription","assertSingleKey","functionDescription","call","describe","desc","setKey","set","demandOption","msg","coerce","builder","populateParserHintDictionary","singleKeyHandler","Array","isArray","objectKeys","deleteFromParserHintObject","optionKey","hintKey","hint","indexOf","splice","getDescriptions","config","applyExtends","getParserConfiguration","deferY18nLookup","example","cmd","description","exampleParams","handler","middlewares","deprecated","addHandler","commandDir","dir","opts","req","addDirectory","demand","required","max","Infinity","demandCommand","min","minMsg","maxMsg","global","demandedCommands","getDemandedOptions","demandedOptions","getDemandedCommands","deprecateOption","option","message","deprecatedOptions","getDeprecatedOptions","implies","conflicts","key1","key2","YError","epilogue","epilog","fail","f","failFn","onFinishCommand","getHandlerFinishCommand","check","_global","globals","g","pkgConf","rootPath","conf","obj","pkgUp","pkgs","npath","startDir","extname","pkgJsonPath","sync","JSON","parse","readFileSync","toString","noop","args","shortCircuit","_parseFn","_parseArgs","tmpParsed","setParsed","_getParseContext","_hasParseCallback","opt","deprecate","configParser","group","hidden","hide","getOptions","positional","supportedOpts","v","accept","fullCommand","parseOptions","cmdToParseOptions","pk","parseOption","getPositionalGroupName","existing","seen","getGroups","prefix","wrap","cols","enabled","getStrict","getStrictCommands","parserConfig","parserConfiguration","showHelp","level","hasDefaultCommand","runDefaultBuilderOn","versionOpt","version","ver","defaultVersionOpt","guessVersion","helpOpt","addHelpOpt","help","defaultHelpOpt","defaultShowHiddenOpt","showHiddenOpt","addShowHiddenOpt","showHidden","hiddenOptions","showHelpOnFail","getExitProcess","fn","registerFunction","showCompletionScript","_logger","log","generateCompletionScript","getCompletion","done","locale","guessLocale","getLocale","detectLocale","setLocale","updateStrings","updateLocale","detect","getDetectLocale","exit","code","err","console","error","_getLoggerInstance","_hasOutput","_setHasOutput","recommendCommands","recommend","getUsageInstance","getValidationInstance","getCommandInstance","terminalWidth","stdout","columns","get","enumerable","parseArgs","_calledFromCommand","commandIndex","__","configuration","populateDoubleDash","detailed","_copyDoubleDash","helpCmds","handlerKeys","getCommands","requestCompletions","completionKey","skipRecommendation","skipDefaultCommand","firstUnknownCommand","i","String","innerArgv","runCommand","completionArgs","completions","showVersion","some","_runValidation","isPromise","apply","_err","runValidation","positionalMap","parseErrors","isDefaultCommand","nonOptionCount","requiredArguments","failedStrictCommands","unknownCommands","unknownArguments","customChecks","limitedChoices","implications","conflicting","LC_ALL","LC_MESSAGES","LANG","LANGUAGE","base","relative","y"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isYargsInstance = exports.rebase = exports.Yargs = void 0;\r\nconst command_1 = require(\"./command\");\r\nconst common_types_1 = require(\"./common-types\");\r\nconst yerror_1 = require(\"./yerror\");\r\nconst usage_1 = require(\"./usage\");\r\nconst argsert_1 = require(\"./argsert\");\r\nconst fs = require(\"fs\");\r\nconst completion_1 = require(\"./completion\");\r\nconst path = require(\"path\");\r\nconst validation_1 = require(\"./validation\");\r\nconst obj_filter_1 = require(\"./obj-filter\");\r\nconst apply_extends_1 = require(\"./apply-extends\");\r\nconst middleware_1 = require(\"./middleware\");\r\nconst processArgv = require(\"./process-argv\");\r\nconst is_promise_1 = require(\"./is-promise\");\r\nconst Parser = require(\"yargs-parser\");\r\nconst y18nFactory = require(\"y18n\");\r\nconst setBlocking = require(\"set-blocking\");\r\nconst findUp = require(\"find-up\");\r\nconst requireMainFilename = require(\"require-main-filename\");\r\nfunction Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {\r\n    const self = {};\r\n    let command;\r\n    let completion = null;\r\n    let groups = {};\r\n    const globalMiddleware = [];\r\n    let output = '';\r\n    const preservedGroups = {};\r\n    let usage;\r\n    let validation;\r\n    let handlerFinishCommand = null;\r\n    const y18n = y18nFactory({\r\n        directory: path.resolve(__dirname, '../../locales'),\r\n        updateFiles: false\r\n    });\r\n    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);\r\n    self.scriptName = function (scriptName) {\r\n        self.customScriptName = true;\r\n        self.$0 = scriptName;\r\n        return self;\r\n    };\r\n    // ignore the node bin, specify this in your\r\n    // bin file with #!/usr/bin/env node\r\n    let default$0;\r\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\r\n        default$0 = process.argv.slice(1, 2);\r\n    }\r\n    else {\r\n        default$0 = process.argv.slice(0, 1);\r\n    }\r\n    self.$0 = default$0\r\n        .map(x => {\r\n        const b = rebase(cwd, x);\r\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\r\n    })\r\n        .join(' ').trim();\r\n    if (process.env._ !== undefined && processArgv.getProcessArgvBin() === process.env._) {\r\n        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, '');\r\n    }\r\n    // use context object to keep track of resets, subcommand execution, etc\r\n    // submodules should modify and check the state of context as necessary\r\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\r\n    self.getContext = () => context;\r\n    // puts yargs back into an initial state. any keys\r\n    // that have been set to \"global\" will not be reset\r\n    // by this action.\r\n    let options;\r\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\r\n        context.resets++;\r\n        options = options || {};\r\n        // put yargs back into an initial state, this\r\n        // logic is used to build a nested command\r\n        // hierarchy.\r\n        const tmpOptions = {};\r\n        tmpOptions.local = options.local ? options.local : [];\r\n        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\r\n        // if a key has been explicitly set as local,\r\n        // we should reset it before passing options to command.\r\n        const localLookup = {};\r\n        tmpOptions.local.forEach((l) => {\r\n            localLookup[l] = true;\r\n            (aliases[l] || []).forEach((a) => {\r\n                localLookup[a] = true;\r\n            });\r\n        });\r\n        // add all groups not set to local to preserved groups\r\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\r\n            const keys = groups[groupName].filter(key => !(key in localLookup));\r\n            if (keys.length > 0) {\r\n                acc[groupName] = keys;\r\n            }\r\n            return acc;\r\n        }, {}));\r\n        // groups can now be reset\r\n        groups = {};\r\n        const arrayOptions = [\r\n            'array', 'boolean', 'string', 'skipValidation',\r\n            'count', 'normalize', 'number',\r\n            'hiddenOptions'\r\n        ];\r\n        const objectOptions = [\r\n            'narg', 'key', 'alias', 'default', 'defaultDescription',\r\n            'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce',\r\n            'deprecatedOptions'\r\n        ];\r\n        arrayOptions.forEach(k => {\r\n            tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\r\n        });\r\n        objectOptions.forEach((k) => {\r\n            tmpOptions[k] = obj_filter_1.objFilter(options[k], k => !localLookup[k]);\r\n        });\r\n        tmpOptions.envPrefix = options.envPrefix;\r\n        options = tmpOptions;\r\n        // if this is the first time being executed, create\r\n        // instances of all our helpers -- otherwise just reset.\r\n        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);\r\n        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);\r\n        command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);\r\n        if (!completion)\r\n            completion = completion_1.completion(self, usage, command);\r\n        completionCommand = null;\r\n        output = '';\r\n        exitError = null;\r\n        hasOutput = false;\r\n        self.parsed = false;\r\n        return self;\r\n    };\r\n    self.resetOptions();\r\n    // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\r\n    const frozens = [];\r\n    function freeze() {\r\n        frozens.push({\r\n            options,\r\n            configObjects: options.configObjects.slice(0),\r\n            exitProcess,\r\n            groups,\r\n            strict,\r\n            strictCommands,\r\n            completionCommand,\r\n            output,\r\n            exitError,\r\n            hasOutput,\r\n            parsed: self.parsed,\r\n            parseFn,\r\n            parseContext,\r\n            handlerFinishCommand\r\n        });\r\n        usage.freeze();\r\n        validation.freeze();\r\n        command.freeze();\r\n    }\r\n    function unfreeze() {\r\n        const frozen = frozens.pop();\r\n        common_types_1.assertNotStrictEqual(frozen, undefined);\r\n        let configObjects;\r\n        ({\r\n            options,\r\n            configObjects,\r\n            exitProcess,\r\n            groups,\r\n            output,\r\n            exitError,\r\n            hasOutput,\r\n            parsed: self.parsed,\r\n            strict,\r\n            strictCommands,\r\n            completionCommand,\r\n            parseFn,\r\n            parseContext,\r\n            handlerFinishCommand\r\n        } = frozen);\r\n        options.configObjects = configObjects;\r\n        usage.unfreeze();\r\n        validation.unfreeze();\r\n        command.unfreeze();\r\n    }\r\n    self.boolean = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('boolean', keys);\r\n        return self;\r\n    };\r\n    self.array = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('array', keys);\r\n        return self;\r\n    };\r\n    self.number = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('number', keys);\r\n        return self;\r\n    };\r\n    self.normalize = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('normalize', keys);\r\n        return self;\r\n    };\r\n    self.count = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('count', keys);\r\n        return self;\r\n    };\r\n    self.string = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('string', keys);\r\n        return self;\r\n    };\r\n    self.requiresArg = function (keys) {\r\n        // the 2nd paramter [number] in the argsert the assertion is mandatory\r\n        // as populateParserHintSingleValueDictionary recursively calls requiresArg\r\n        // with Nan as a 2nd parameter, although we ignore it\r\n        argsert_1.argsert('<array|string|object> [number]', [keys], arguments.length);\r\n        // If someone configures nargs at the same time as requiresArg,\r\n        // nargs should take precedent,\r\n        // see: https://github.com/yargs/yargs/pull/1572\r\n        // TODO: make this work with aliases, using a check similar to\r\n        // checkAllAliases() in yargs-parser.\r\n        if (typeof keys === 'string' && options.narg[keys]) {\r\n            return self;\r\n        }\r\n        else {\r\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\r\n        }\r\n        return self;\r\n    };\r\n    self.skipValidation = function (keys) {\r\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\r\n        populateParserHintArray('skipValidation', keys);\r\n        return self;\r\n    };\r\n    function populateParserHintArray(type, keys) {\r\n        keys = [].concat(keys);\r\n        keys.forEach((key) => {\r\n            key = sanitizeKey(key);\r\n            options[type].push(key);\r\n        });\r\n    }\r\n    self.nargs = function (key, value) {\r\n        argsert_1.argsert('<string|object|array> [number]', [key, value], arguments.length);\r\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\r\n        return self;\r\n    };\r\n    self.choices = function (key, value) {\r\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\r\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\r\n        return self;\r\n    };\r\n    self.alias = function (key, value) {\r\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\r\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\r\n        return self;\r\n    };\r\n    // TODO: actually deprecate self.defaults.\r\n    self.default = self.defaults = function (key, value, defaultDescription) {\r\n        argsert_1.argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\r\n        if (defaultDescription) {\r\n            common_types_1.assertSingleKey(key);\r\n            options.defaultDescription[key] = defaultDescription;\r\n        }\r\n        if (typeof value === 'function') {\r\n            common_types_1.assertSingleKey(key);\r\n            if (!options.defaultDescription[key])\r\n                options.defaultDescription[key] = usage.functionDescription(value);\r\n            value = value.call();\r\n        }\r\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\r\n        return self;\r\n    };\r\n    self.describe = function (key, desc) {\r\n        argsert_1.argsert('<object|string|array> [string]', [key, desc], arguments.length);\r\n        setKey(key, true);\r\n        usage.describe(key, desc);\r\n        return self;\r\n    };\r\n    function setKey(key, set) {\r\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\r\n        return self;\r\n    }\r\n    function demandOption(keys, msg) {\r\n        argsert_1.argsert('<object|string|array> [string]', [keys, msg], arguments.length);\r\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\r\n        return self;\r\n    }\r\n    self.demandOption = demandOption;\r\n    self.coerce = function (keys, value) {\r\n        argsert_1.argsert('<object|string|array> [function]', [keys, value], arguments.length);\r\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\r\n        return self;\r\n    };\r\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\r\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\r\n            options[type][key] = value;\r\n        });\r\n    }\r\n    function populateParserHintArrayDictionary(builder, type, key, value) {\r\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\r\n            options[type][key] = (options[type][key] || []).concat(value);\r\n        });\r\n    }\r\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\r\n        if (Array.isArray(key)) {\r\n            // an array of keys with one value ['x', 'y', 'z'], function parse () {}\r\n            key.forEach((k) => {\r\n                builder(k, value);\r\n            });\r\n        }\r\n        else if (((key) => typeof key === 'object')(key)) {\r\n            // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\r\n            for (const k of common_types_1.objectKeys(key)) {\r\n                builder(k, key[k]);\r\n            }\r\n        }\r\n        else {\r\n            singleKeyHandler(type, sanitizeKey(key), value);\r\n        }\r\n    }\r\n    function sanitizeKey(key) {\r\n        if (key === '__proto__')\r\n            return '___proto___';\r\n        return key;\r\n    }\r\n    function deleteFromParserHintObject(optionKey) {\r\n        // delete from all parsing hints:\r\n        // boolean, array, key, alias, etc.\r\n        common_types_1.objectKeys(options).forEach((hintKey) => {\r\n            // configObjects is not a parsing hint array\r\n            if (((key) => key === 'configObjects')(hintKey))\r\n                return;\r\n            const hint = options[hintKey];\r\n            if (Array.isArray(hint)) {\r\n                if (~hint.indexOf(optionKey))\r\n                    hint.splice(hint.indexOf(optionKey), 1);\r\n            }\r\n            else if (typeof hint === 'object') {\r\n                delete hint[optionKey];\r\n            }\r\n        });\r\n        // now delete the description from usage.js.\r\n        delete usage.getDescriptions()[optionKey];\r\n    }\r\n    self.config = function config(key = 'config', msg, parseFn) {\r\n        argsert_1.argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\r\n        // allow a config object to be provided directly.\r\n        if ((typeof key === 'object') && !Array.isArray(key)) {\r\n            key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config']);\r\n            options.configObjects = (options.configObjects || []).concat(key);\r\n            return self;\r\n        }\r\n        // allow for a custom parsing function.\r\n        if (typeof msg === 'function') {\r\n            parseFn = msg;\r\n            msg = undefined;\r\n        }\r\n        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\r\n        (Array.isArray(key) ? key : [key]).forEach((k) => {\r\n            options.config[k] = parseFn || true;\r\n        });\r\n        return self;\r\n    };\r\n    self.example = function (cmd, description) {\r\n        argsert_1.argsert('<string|array> [string]', [cmd, description], arguments.length);\r\n        if (Array.isArray(cmd)) {\r\n            cmd.forEach((exampleParams) => self.example(...exampleParams));\r\n        }\r\n        else {\r\n            usage.example(cmd, description);\r\n        }\r\n        return self;\r\n    };\r\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\r\n        argsert_1.argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\r\n        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\r\n        return self;\r\n    };\r\n    self.commandDir = function (dir, opts) {\r\n        argsert_1.argsert('<string> [object]', [dir, opts], arguments.length);\r\n        const req = parentRequire || require;\r\n        command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\r\n        return self;\r\n    };\r\n    // TODO: deprecate self.demand in favor of\r\n    // .demandCommand() .demandOption().\r\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\r\n        // you can optionally provide a 'max' key,\r\n        // which will raise an exception if too many '_'\r\n        // options are provided.\r\n        if (Array.isArray(max)) {\r\n            max.forEach((key) => {\r\n                common_types_1.assertNotStrictEqual(msg, true);\r\n                demandOption(key, msg);\r\n            });\r\n            max = Infinity;\r\n        }\r\n        else if (typeof max !== 'number') {\r\n            msg = max;\r\n            max = Infinity;\r\n        }\r\n        if (typeof keys === 'number') {\r\n            common_types_1.assertNotStrictEqual(msg, true);\r\n            self.demandCommand(keys, max, msg, msg);\r\n        }\r\n        else if (Array.isArray(keys)) {\r\n            keys.forEach((key) => {\r\n                common_types_1.assertNotStrictEqual(msg, true);\r\n                demandOption(key, msg);\r\n            });\r\n        }\r\n        else {\r\n            if (typeof msg === 'string') {\r\n                demandOption(keys, msg);\r\n            }\r\n            else if (msg === true || typeof msg === 'undefined') {\r\n                demandOption(keys);\r\n            }\r\n        }\r\n        return self;\r\n    };\r\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\r\n        argsert_1.argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\r\n        if (typeof max !== 'number') {\r\n            minMsg = max;\r\n            max = Infinity;\r\n        }\r\n        self.global('_', false);\r\n        options.demandedCommands._ = {\r\n            min,\r\n            max,\r\n            minMsg,\r\n            maxMsg\r\n        };\r\n        return self;\r\n    };\r\n    self.getDemandedOptions = () => {\r\n        argsert_1.argsert([], 0);\r\n        return options.demandedOptions;\r\n    };\r\n    self.getDemandedCommands = () => {\r\n        argsert_1.argsert([], 0);\r\n        return options.demandedCommands;\r\n    };\r\n    self.deprecateOption = function deprecateOption(option, message) {\r\n        argsert_1.argsert('<string> [string|boolean]', [option, message], arguments.length);\r\n        options.deprecatedOptions[option] = message;\r\n        return self;\r\n    };\r\n    self.getDeprecatedOptions = () => {\r\n        argsert_1.argsert([], 0);\r\n        return options.deprecatedOptions;\r\n    };\r\n    self.implies = function (key, value) {\r\n        argsert_1.argsert('<string|object> [number|string|array]', [key, value], arguments.length);\r\n        validation.implies(key, value);\r\n        return self;\r\n    };\r\n    self.conflicts = function (key1, key2) {\r\n        argsert_1.argsert('<string|object> [string|array]', [key1, key2], arguments.length);\r\n        validation.conflicts(key1, key2);\r\n        return self;\r\n    };\r\n    self.usage = function (msg, description, builder, handler) {\r\n        argsert_1.argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\r\n        if (description !== undefined) {\r\n            common_types_1.assertNotStrictEqual(msg, null);\r\n            // .usage() can be used as an alias for defining\r\n            // a default command.\r\n            if ((msg || '').match(/^\\$0( |$)/)) {\r\n                return self.command(msg, description, builder, handler);\r\n            }\r\n            else {\r\n                throw new yerror_1.YError('.usage() description must start with $0 if being used as alias for .command()');\r\n            }\r\n        }\r\n        else {\r\n            usage.usage(msg);\r\n            return self;\r\n        }\r\n    };\r\n    self.epilogue = self.epilog = function (msg) {\r\n        argsert_1.argsert('<string>', [msg], arguments.length);\r\n        usage.epilog(msg);\r\n        return self;\r\n    };\r\n    self.fail = function (f) {\r\n        argsert_1.argsert('<function>', [f], arguments.length);\r\n        usage.failFn(f);\r\n        return self;\r\n    };\r\n    self.onFinishCommand = function (f) {\r\n        argsert_1.argsert('<function>', [f], arguments.length);\r\n        handlerFinishCommand = f;\r\n        return self;\r\n    };\r\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\r\n    self.check = function (f, _global) {\r\n        argsert_1.argsert('<function> [boolean]', [f, _global], arguments.length);\r\n        validation.check(f, _global !== false);\r\n        return self;\r\n    };\r\n    self.global = function global(globals, global) {\r\n        argsert_1.argsert('<string|array> [boolean]', [globals, global], arguments.length);\r\n        globals = [].concat(globals);\r\n        if (global !== false) {\r\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\r\n        }\r\n        else {\r\n            globals.forEach((g) => {\r\n                if (options.local.indexOf(g) === -1)\r\n                    options.local.push(g);\r\n            });\r\n        }\r\n        return self;\r\n    };\r\n    self.pkgConf = function pkgConf(key, rootPath) {\r\n        argsert_1.argsert('<string> [string]', [key, rootPath], arguments.length);\r\n        let conf = null;\r\n        // prefer cwd to require-main-filename in this method\r\n        // since we're looking for e.g. \"nyc\" config in nyc consumer\r\n        // rather than \"yargs\" config in nyc (where nyc is the main filename)\r\n        const obj = pkgUp(rootPath || cwd);\r\n        // If an object exists in the key, add it to options.configObjects\r\n        if (obj[key] && typeof obj[key] === 'object') {\r\n            conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config']);\r\n            options.configObjects = (options.configObjects || []).concat(conf);\r\n        }\r\n        return self;\r\n    };\r\n    const pkgs = {};\r\n    function pkgUp(rootPath) {\r\n        const npath = rootPath || '*';\r\n        if (pkgs[npath])\r\n            return pkgs[npath];\r\n        let obj = {};\r\n        try {\r\n            let startDir = rootPath || requireMainFilename(parentRequire);\r\n            // When called in an environment that lacks require.main.filename, such as a jest test runner,\r\n            // startDir is already process.cwd(), and should not be shortened.\r\n            // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\r\n            if (!rootPath && path.extname(startDir)) {\r\n                startDir = path.dirname(startDir);\r\n            }\r\n            const pkgJsonPath = findUp.sync('package.json', {\r\n                cwd: startDir\r\n            });\r\n            common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);\r\n            obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());\r\n        }\r\n        catch (noop) { }\r\n        pkgs[npath] = obj || {};\r\n        return pkgs[npath];\r\n    }\r\n    let parseFn = null;\r\n    let parseContext = null;\r\n    self.parse = function parse(args, shortCircuit, _parseFn) {\r\n        argsert_1.argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\r\n        freeze();\r\n        if (typeof args === 'undefined') {\r\n            const argv = self._parseArgs(processArgs);\r\n            const tmpParsed = self.parsed;\r\n            unfreeze();\r\n            // TODO: remove this compatibility hack when we release yargs@15.x:\r\n            self.parsed = tmpParsed;\r\n            return argv;\r\n        }\r\n        // a context object can optionally be provided, this allows\r\n        // additional information to be passed to a command handler.\r\n        if (typeof shortCircuit === 'object') {\r\n            parseContext = shortCircuit;\r\n            shortCircuit = _parseFn;\r\n        }\r\n        // by providing a function as a second argument to\r\n        // parse you can capture output that would otherwise\r\n        // default to printing to stdout/stderr.\r\n        if (typeof shortCircuit === 'function') {\r\n            parseFn = shortCircuit;\r\n            shortCircuit = false;\r\n        }\r\n        // completion short-circuits the parsing process,\r\n        // skipping validation, etc.\r\n        if (!shortCircuit)\r\n            processArgs = args;\r\n        if (parseFn)\r\n            exitProcess = false;\r\n        const parsed = self._parseArgs(args, !!shortCircuit);\r\n        completion.setParsed(self.parsed);\r\n        if (parseFn)\r\n            parseFn(exitError, parsed, output);\r\n        unfreeze();\r\n        return parsed;\r\n    };\r\n    self._getParseContext = () => parseContext || {};\r\n    self._hasParseCallback = () => !!parseFn;\r\n    self.option = self.options = function option(key, opt) {\r\n        argsert_1.argsert('<string|object> [object]', [key, opt], arguments.length);\r\n        if (typeof key === 'object') {\r\n            Object.keys(key).forEach((k) => {\r\n                self.options(k, key[k]);\r\n            });\r\n        }\r\n        else {\r\n            if (typeof opt !== 'object') {\r\n                opt = {};\r\n            }\r\n            options.key[key] = true; // track manually set keys.\r\n            if (opt.alias)\r\n                self.alias(key, opt.alias);\r\n            const deprecate = opt.deprecate || opt.deprecated;\r\n            if (deprecate) {\r\n                self.deprecateOption(key, deprecate);\r\n            }\r\n            const demand = opt.demand || opt.required || opt.require;\r\n            // A required option can be specified via \"demand: true\".\r\n            if (demand) {\r\n                self.demand(key, demand);\r\n            }\r\n            if (opt.demandOption) {\r\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\r\n            }\r\n            if (opt.conflicts) {\r\n                self.conflicts(key, opt.conflicts);\r\n            }\r\n            if ('default' in opt) {\r\n                self.default(key, opt.default);\r\n            }\r\n            if (opt.implies !== undefined) {\r\n                self.implies(key, opt.implies);\r\n            }\r\n            if (opt.nargs !== undefined) {\r\n                self.nargs(key, opt.nargs);\r\n            }\r\n            if (opt.config) {\r\n                self.config(key, opt.configParser);\r\n            }\r\n            if (opt.normalize) {\r\n                self.normalize(key);\r\n            }\r\n            if (opt.choices) {\r\n                self.choices(key, opt.choices);\r\n            }\r\n            if (opt.coerce) {\r\n                self.coerce(key, opt.coerce);\r\n            }\r\n            if (opt.group) {\r\n                self.group(key, opt.group);\r\n            }\r\n            if (opt.boolean || opt.type === 'boolean') {\r\n                self.boolean(key);\r\n                if (opt.alias)\r\n                    self.boolean(opt.alias);\r\n            }\r\n            if (opt.array || opt.type === 'array') {\r\n                self.array(key);\r\n                if (opt.alias)\r\n                    self.array(opt.alias);\r\n            }\r\n            if (opt.number || opt.type === 'number') {\r\n                self.number(key);\r\n                if (opt.alias)\r\n                    self.number(opt.alias);\r\n            }\r\n            if (opt.string || opt.type === 'string') {\r\n                self.string(key);\r\n                if (opt.alias)\r\n                    self.string(opt.alias);\r\n            }\r\n            if (opt.count || opt.type === 'count') {\r\n                self.count(key);\r\n            }\r\n            if (typeof opt.global === 'boolean') {\r\n                self.global(key, opt.global);\r\n            }\r\n            if (opt.defaultDescription) {\r\n                options.defaultDescription[key] = opt.defaultDescription;\r\n            }\r\n            if (opt.skipValidation) {\r\n                self.skipValidation(key);\r\n            }\r\n            const desc = opt.describe || opt.description || opt.desc;\r\n            self.describe(key, desc);\r\n            if (opt.hidden) {\r\n                self.hide(key);\r\n            }\r\n            if (opt.requiresArg) {\r\n                self.requiresArg(key);\r\n            }\r\n        }\r\n        return self;\r\n    };\r\n    self.getOptions = () => options;\r\n    self.positional = function (key, opts) {\r\n        argsert_1.argsert('<string> <object>', [key, opts], arguments.length);\r\n        if (context.resets === 0) {\r\n            throw new yerror_1.YError(\".positional() can only be called in a command's builder function\");\r\n        }\r\n        // .positional() only supports a subset of the configuration\r\n        // options available to .option().\r\n        const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',\r\n            'choices', 'conflicts', 'coerce', 'type', 'describe',\r\n            'desc', 'description', 'alias'];\r\n        opts = obj_filter_1.objFilter(opts, (k, v) => {\r\n            let accept = supportedOpts.indexOf(k) !== -1;\r\n            // type can be one of string|number|boolean.\r\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\r\n                accept = false;\r\n            return accept;\r\n        });\r\n        // copy over any settings that can be inferred from the command string.\r\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\r\n        const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\r\n            array: [],\r\n            alias: {},\r\n            default: {},\r\n            demand: {}\r\n        };\r\n        common_types_1.objectKeys(parseOptions).forEach((pk) => {\r\n            const parseOption = parseOptions[pk];\r\n            if (Array.isArray(parseOption)) {\r\n                if (parseOption.indexOf(key) !== -1)\r\n                    opts[pk] = true;\r\n            }\r\n            else {\r\n                if (parseOption[key] && !(pk in opts))\r\n                    opts[pk] = parseOption[key];\r\n            }\r\n        });\r\n        self.group(key, usage.getPositionalGroupName());\r\n        return self.option(key, opts);\r\n    };\r\n    self.group = function group(opts, groupName) {\r\n        argsert_1.argsert('<string|array> <string>', [opts, groupName], arguments.length);\r\n        const existing = preservedGroups[groupName] || groups[groupName];\r\n        if (preservedGroups[groupName]) {\r\n            // we now only need to track this group name in groups.\r\n            delete preservedGroups[groupName];\r\n        }\r\n        const seen = {};\r\n        groups[groupName] = (existing || []).concat(opts).filter((key) => {\r\n            if (seen[key])\r\n                return false;\r\n            return (seen[key] = true);\r\n        });\r\n        return self;\r\n    };\r\n    // combine explicit and preserved groups. explicit groups should be first\r\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\r\n    // as long as options.envPrefix is not undefined,\r\n    // parser will apply env vars matching prefix to argv\r\n    self.env = function (prefix) {\r\n        argsert_1.argsert('[string|boolean]', [prefix], arguments.length);\r\n        if (prefix === false)\r\n            delete options.envPrefix;\r\n        else\r\n            options.envPrefix = prefix || '';\r\n        return self;\r\n    };\r\n    self.wrap = function (cols) {\r\n        argsert_1.argsert('<number|null|undefined>', [cols], arguments.length);\r\n        usage.wrap(cols);\r\n        return self;\r\n    };\r\n    let strict = false;\r\n    self.strict = function (enabled) {\r\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\r\n        strict = enabled !== false;\r\n        return self;\r\n    };\r\n    self.getStrict = () => strict;\r\n    let strictCommands = false;\r\n    self.strictCommands = function (enabled) {\r\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\r\n        strictCommands = enabled !== false;\r\n        return self;\r\n    };\r\n    self.getStrictCommands = () => strictCommands;\r\n    let parserConfig = {};\r\n    self.parserConfiguration = function parserConfiguration(config) {\r\n        argsert_1.argsert('<object>', [config], arguments.length);\r\n        parserConfig = config;\r\n        return self;\r\n    };\r\n    self.getParserConfiguration = () => parserConfig;\r\n    self.showHelp = function (level) {\r\n        argsert_1.argsert('[string|function]', [level], arguments.length);\r\n        if (!self.parsed)\r\n            self._parseArgs(processArgs); // run parser, if it has not already been executed.\r\n        if (command.hasDefaultCommand()) {\r\n            context.resets++; // override the restriction on top-level positoinals.\r\n            command.runDefaultBuilderOn(self);\r\n        }\r\n        usage.showHelp(level);\r\n        return self;\r\n    };\r\n    let versionOpt = null;\r\n    self.version = function version(opt, msg, ver) {\r\n        const defaultVersionOpt = 'version';\r\n        argsert_1.argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\r\n        // nuke the key previously configured\r\n        // to return version #.\r\n        if (versionOpt) {\r\n            deleteFromParserHintObject(versionOpt);\r\n            usage.version(undefined);\r\n            versionOpt = null;\r\n        }\r\n        if (arguments.length === 0) {\r\n            ver = guessVersion();\r\n            opt = defaultVersionOpt;\r\n        }\r\n        else if (arguments.length === 1) {\r\n            if (opt === false) { // disable default 'version' key.\r\n                return self;\r\n            }\r\n            ver = opt;\r\n            opt = defaultVersionOpt;\r\n        }\r\n        else if (arguments.length === 2) {\r\n            ver = msg;\r\n            msg = undefined;\r\n        }\r\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\r\n        msg = msg || usage.deferY18nLookup('Show version number');\r\n        usage.version(ver || undefined);\r\n        self.boolean(versionOpt);\r\n        self.describe(versionOpt, msg);\r\n        return self;\r\n    };\r\n    function guessVersion() {\r\n        const obj = pkgUp();\r\n        return obj.version || 'unknown';\r\n    }\r\n    let helpOpt = null;\r\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\r\n        const defaultHelpOpt = 'help';\r\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\r\n        // nuke the key previously configured\r\n        // to return help.\r\n        if (helpOpt) {\r\n            deleteFromParserHintObject(helpOpt);\r\n            helpOpt = null;\r\n        }\r\n        if (arguments.length === 1) {\r\n            if (opt === false)\r\n                return self;\r\n        }\r\n        // use arguments, fallback to defaults for opt and msg\r\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\r\n        self.boolean(helpOpt);\r\n        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\r\n        return self;\r\n    };\r\n    const defaultShowHiddenOpt = 'show-hidden';\r\n    options.showHiddenOpt = defaultShowHiddenOpt;\r\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\r\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\r\n        if (arguments.length === 1) {\r\n            if (opt === false)\r\n                return self;\r\n        }\r\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\r\n        self.boolean(showHiddenOpt);\r\n        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\r\n        options.showHiddenOpt = showHiddenOpt;\r\n        return self;\r\n    };\r\n    self.hide = function hide(key) {\r\n        argsert_1.argsert('<string>', [key], arguments.length);\r\n        options.hiddenOptions.push(key);\r\n        return self;\r\n    };\r\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\r\n        argsert_1.argsert('[boolean|string] [string]', [enabled, message], arguments.length);\r\n        usage.showHelpOnFail(enabled, message);\r\n        return self;\r\n    };\r\n    var exitProcess = true;\r\n    self.exitProcess = function (enabled = true) {\r\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\r\n        exitProcess = enabled;\r\n        return self;\r\n    };\r\n    self.getExitProcess = () => exitProcess;\r\n    var completionCommand = null;\r\n    self.completion = function (cmd, desc, fn) {\r\n        argsert_1.argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\r\n        // a function to execute when generating\r\n        // completions can be provided as the second\r\n        // or third argument to completion.\r\n        if (typeof desc === 'function') {\r\n            fn = desc;\r\n            desc = undefined;\r\n        }\r\n        // register the completion command.\r\n        completionCommand = cmd || completionCommand || 'completion';\r\n        if (!desc && desc !== false) {\r\n            desc = 'generate completion script';\r\n        }\r\n        self.command(completionCommand, desc);\r\n        // a function can be provided\r\n        if (fn)\r\n            completion.registerFunction(fn);\r\n        return self;\r\n    };\r\n    self.showCompletionScript = function ($0, cmd) {\r\n        argsert_1.argsert('[string] [string]', [$0, cmd], arguments.length);\r\n        $0 = $0 || self.$0;\r\n        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\r\n        return self;\r\n    };\r\n    self.getCompletion = function (args, done) {\r\n        argsert_1.argsert('<array> <function>', [args, done], arguments.length);\r\n        completion.getCompletion(args, done);\r\n    };\r\n    self.locale = function (locale) {\r\n        argsert_1.argsert('[string]', [locale], arguments.length);\r\n        if (!locale) {\r\n            guessLocale();\r\n            return y18n.getLocale();\r\n        }\r\n        detectLocale = false;\r\n        y18n.setLocale(locale);\r\n        return self;\r\n    };\r\n    self.updateStrings = self.updateLocale = function (obj) {\r\n        argsert_1.argsert('<object>', [obj], arguments.length);\r\n        detectLocale = false;\r\n        y18n.updateLocale(obj);\r\n        return self;\r\n    };\r\n    let detectLocale = true;\r\n    self.detectLocale = function (detect) {\r\n        argsert_1.argsert('<boolean>', [detect], arguments.length);\r\n        detectLocale = detect;\r\n        return self;\r\n    };\r\n    self.getDetectLocale = () => detectLocale;\r\n    var hasOutput = false;\r\n    var exitError = null;\r\n    // maybe exit, always capture\r\n    // context about why we wanted to exit.\r\n    self.exit = (code, err) => {\r\n        hasOutput = true;\r\n        exitError = err;\r\n        if (exitProcess)\r\n            process.exit(code);\r\n    };\r\n    // we use a custom logger that buffers output,\r\n    // so that we can print to non-CLIs, e.g., chat-bots.\r\n    const _logger = {\r\n        log(...args) {\r\n            if (!self._hasParseCallback())\r\n                console.log(...args);\r\n            hasOutput = true;\r\n            if (output.length)\r\n                output += '\\n';\r\n            output += args.join(' ');\r\n        },\r\n        error(...args) {\r\n            if (!self._hasParseCallback())\r\n                console.error(...args);\r\n            hasOutput = true;\r\n            if (output.length)\r\n                output += '\\n';\r\n            output += args.join(' ');\r\n        }\r\n    };\r\n    self._getLoggerInstance = () => _logger;\r\n    // has yargs output an error our help\r\n    // message in the current execution context.\r\n    self._hasOutput = () => hasOutput;\r\n    self._setHasOutput = () => {\r\n        hasOutput = true;\r\n    };\r\n    let recommendCommands;\r\n    self.recommendCommands = function (recommend = true) {\r\n        argsert_1.argsert('[boolean]', [recommend], arguments.length);\r\n        recommendCommands = recommend;\r\n        return self;\r\n    };\r\n    self.getUsageInstance = () => usage;\r\n    self.getValidationInstance = () => validation;\r\n    self.getCommandInstance = () => command;\r\n    self.terminalWidth = () => {\r\n        argsert_1.argsert([], 0);\r\n        return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\r\n    };\r\n    Object.defineProperty(self, 'argv', {\r\n        get: () => self._parseArgs(processArgs),\r\n        enumerable: true\r\n    });\r\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\r\n        let skipValidation = !!_calledFromCommand;\r\n        args = args || processArgs;\r\n        options.__ = y18n.__;\r\n        options.configuration = self.getParserConfiguration();\r\n        const populateDoubleDash = !!options.configuration['populate--'];\r\n        const config = Object.assign({}, options.configuration, {\r\n            'populate--': true\r\n        });\r\n        const parsed = Parser.detailed(args, Object.assign({}, options, {\r\n            configuration: config\r\n        }));\r\n        let argv = parsed.argv;\r\n        if (parseContext)\r\n            argv = Object.assign({}, argv, parseContext);\r\n        const aliases = parsed.aliases;\r\n        argv.$0 = self.$0;\r\n        self.parsed = parsed;\r\n        try {\r\n            guessLocale(); // guess locale lazily, so that it can be turned off in chain.\r\n            // while building up the argv object, there\r\n            // are two passes through the parser. If completion\r\n            // is being performed short-circuit on the first pass.\r\n            if (shortCircuit) {\r\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\r\n            }\r\n            // if there's a handler associated with a\r\n            // command defer processing to it.\r\n            if (helpOpt) {\r\n                // consider any multi-char helpOpt alias as a valid help command\r\n                // unless all helpOpt aliases are single-char\r\n                // note that parsed.aliases is a normalized bidirectional map :)\r\n                const helpCmds = [helpOpt]\r\n                    .concat(aliases[helpOpt] || [])\r\n                    .filter(k => k.length > 1);\r\n                // check if help should trigger and strip it from _.\r\n                if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\r\n                    argv._.pop();\r\n                    argv[helpOpt] = true;\r\n                }\r\n            }\r\n            const handlerKeys = command.getCommands();\r\n            const requestCompletions = completion.completionKey in argv;\r\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\r\n            const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\r\n            if (argv._.length) {\r\n                if (handlerKeys.length) {\r\n                    let firstUnknownCommand;\r\n                    for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\r\n                        cmd = String(argv._[i]);\r\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\r\n                            // commands are executed using a recursive algorithm that executes\r\n                            // the deepest command first; we keep track of the position in the\r\n                            // argv._ array that is currently being executed.\r\n                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\r\n                            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\r\n                        }\r\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\r\n                            firstUnknownCommand = cmd;\r\n                            break;\r\n                        }\r\n                    }\r\n                    // run the default command, if defined\r\n                    if (command.hasDefaultCommand() && !skipDefaultCommand) {\r\n                        const innerArgv = command.runCommand(null, self, parsed);\r\n                        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\r\n                    }\r\n                    // recommend a command if recommendCommands() has\r\n                    // been enabled, and no commands were found to execute\r\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\r\n                        validation.recommendCommands(firstUnknownCommand, handlerKeys);\r\n                    }\r\n                }\r\n                // generate a completion script for adding to ~/.bashrc.\r\n                if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\r\n                    if (exitProcess)\r\n                        setBlocking(true);\r\n                    self.showCompletionScript();\r\n                    self.exit(0);\r\n                }\r\n            }\r\n            else if (command.hasDefaultCommand() && !skipDefaultCommand) {\r\n                const innerArgv = command.runCommand(null, self, parsed);\r\n                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\r\n            }\r\n            // we must run completions first, a user might\r\n            // want to complete the --help or --version option.\r\n            if (requestCompletions) {\r\n                if (exitProcess)\r\n                    setBlocking(true);\r\n                // we allow for asynchronous completions,\r\n                // e.g., loading in a list of commands from an API.\r\n                args = [].concat(args);\r\n                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\r\n                completion.getCompletion(completionArgs, (completions) => {\r\n                    ;\r\n                    (completions || []).forEach((completion) => {\r\n                        _logger.log(completion);\r\n                    });\r\n                    self.exit(0);\r\n                });\r\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\r\n            }\r\n            // Handle 'help' and 'version' options\r\n            // if we haven't already output help!\r\n            if (!hasOutput) {\r\n                Object.keys(argv).forEach((key) => {\r\n                    if (key === helpOpt && argv[key]) {\r\n                        if (exitProcess)\r\n                            setBlocking(true);\r\n                        skipValidation = true;\r\n                        self.showHelp('log');\r\n                        self.exit(0);\r\n                    }\r\n                    else if (key === versionOpt && argv[key]) {\r\n                        if (exitProcess)\r\n                            setBlocking(true);\r\n                        skipValidation = true;\r\n                        usage.showVersion();\r\n                        self.exit(0);\r\n                    }\r\n                });\r\n            }\r\n            // Check if any of the options to skip validation were provided\r\n            if (!skipValidation && options.skipValidation.length > 0) {\r\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\r\n            }\r\n            // If the help or version options where used and exitProcess is false,\r\n            // or if explicitly skipped, we won't run validations.\r\n            if (!skipValidation) {\r\n                if (parsed.error)\r\n                    throw new yerror_1.YError(parsed.error.message);\r\n                // if we're executed via bash completion, don't\r\n                // bother with validation.\r\n                if (!requestCompletions) {\r\n                    self._runValidation(argv, aliases, {}, parsed.error);\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof yerror_1.YError)\r\n                usage.fail(err.message, err);\r\n            else\r\n                throw err;\r\n        }\r\n        return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\r\n    };\r\n    // to simplify the parsing of positionals in commands,\r\n    // we temporarily populate '--' rather than _, with arguments\r\n    // after the '--' directive. After the parse, we copy these back.\r\n    self._copyDoubleDash = function (argv) {\r\n        if (is_promise_1.isPromise(argv) || !argv._ || !argv['--'])\r\n            return argv;\r\n        argv._.push.apply(argv._, argv['--']);\r\n        // TODO(bcoe): refactor command parsing such that this delete is not\r\n        // necessary: https://github.com/yargs/yargs/issues/1482\r\n        try {\r\n            delete argv['--'];\r\n        }\r\n        catch (_err) { }\r\n        return argv;\r\n    };\r\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\r\n        if (parseErrors)\r\n            throw new yerror_1.YError(parseErrors.message);\r\n        validation.nonOptionCount(argv);\r\n        validation.requiredArguments(argv);\r\n        let failedStrictCommands = false;\r\n        if (strictCommands) {\r\n            failedStrictCommands = validation.unknownCommands(argv);\r\n        }\r\n        if (strict && !failedStrictCommands) {\r\n            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\r\n        }\r\n        validation.customChecks(argv, aliases);\r\n        validation.limitedChoices(argv);\r\n        validation.implications(argv);\r\n        validation.conflicting(argv);\r\n    };\r\n    function guessLocale() {\r\n        if (!detectLocale)\r\n            return;\r\n        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || 'en_US';\r\n        self.locale(locale.replace(/[.:].*/, ''));\r\n    }\r\n    // an app should almost always have --version and --help,\r\n    // if you *really* want to disable this use .help(false)/.version(false).\r\n    self.help();\r\n    self.version();\r\n    return self;\r\n}\r\nexports.Yargs = Yargs;\r\n// rebase an absolute path to a relative one with respect to a base directory\r\n// exported for tests\r\nfunction rebase(base, dir) {\r\n    return path.relative(base, dir);\r\n}\r\nexports.rebase = rebase;\r\nfunction isYargsInstance(y) {\r\n    return !!y && (typeof y._parseArgs === 'function');\r\n}\r\nexports.isYargsInstance = isYargsInstance;\r\n"]},"metadata":{},"sourceType":"script"}