{"ast":null,"code":"const camelCase = require('camelcase');\n\nconst decamelize = require('decamelize');\n\nconst path = require('path');\n\nconst tokenizeArgString = require('./lib/tokenize-arg-string');\n\nconst util = require('util');\n\nfunction parse(args, opts) {\n  opts = Object.assign(Object.create(null), opts); // allow a string argument to be passed in rather\n  // than an argv array.\n\n  args = tokenizeArgString(args); // aliases might have transitive relationships, normalize this.\n\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n  const configuration = Object.assign({\n    'boolean-negation': true,\n    'camel-case-expansion': true,\n    'combine-arrays': false,\n    'dot-notation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'greedy-arrays': true,\n    'halt-at-non-option': false,\n    'nargs-eats-options': false,\n    'negation-prefix': 'no-',\n    'parse-numbers': true,\n    'populate--': false,\n    'set-placeholder-key': false,\n    'short-option-groups': true,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration);\n  const defaults = Object.assign(Object.create(null), opts.default);\n  const configObjects = opts.configObjects || [];\n  const envPrefix = opts.envPrefix;\n  const notFlagsOption = configuration['populate--'];\n  const notFlagsArgv = notFlagsOption ? '--' : '_';\n  const newAliases = Object.create(null);\n  const defaulted = Object.create(null); // allow a i18n handler to be passed in, default to a fake one (util.format).\n\n  const __ = opts.__ || util.format;\n\n  const flags = {\n    aliases: Object.create(null),\n    arrays: Object.create(null),\n    bools: Object.create(null),\n    strings: Object.create(null),\n    numbers: Object.create(null),\n    counts: Object.create(null),\n    normalize: Object.create(null),\n    configs: Object.create(null),\n    nargs: Object.create(null),\n    coercions: Object.create(null),\n    keys: []\n  };\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n  [].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    const key = opt.key || opt; // assign to flags[bools|strings|numbers]\n\n    const assignment = Object.keys(opt).map(function (key) {\n      return {\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      }[key];\n    }).filter(Boolean).pop(); // assign key to be coerced\n\n    if (assignment) {\n      flags[assignment][key] = true;\n    }\n\n    flags.arrays[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true;\n    flags.keys.push(key);\n  });\n  [].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true;\n    flags.keys.push(key);\n  });\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k];\n    flags.keys.push(k);\n  });\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k];\n    flags.keys.push(k);\n  });\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;\n    [].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true;\n    });\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k];\n    });\n  } // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n\n\n  extendAliases(opts.key, aliases, opts.default, flags.arrays); // apply default values to all aliases.\n\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key];\n    });\n  });\n  let error = null;\n  checkConfiguration();\n  let notFlags = [];\n  const argv = Object.assign(Object.create(null), {\n    _: []\n  }); // TODO(bcoe): for the first pass at removing object prototype  we didn't\n  // remove all prototypes from objects returned by this API, we might want\n  // to gradually move towards doing so.\n\n  const argvReturn = {};\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n    let broken;\n    let key;\n    let letters;\n    let m;\n    let next;\n    let value; // any unknown option (except for end-of-options, \"--\")\n\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n      argv._.push(arg); // -- separated by =\n\n    } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/); // arrays format = '--f=a b c'\n\n      if (checkAllAliases(m[1], flags.arrays)) {\n        i = eatArray(i, m[1], args, m[2]);\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n        // nargs format = '--f=monkey washing cat'\n        i = eatNargs(i, m[1], args, m[2]);\n      } else {\n        setArg(m[1], m[2]);\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1];\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false); // -- separated by space.\n    } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n      key = arg.match(/^--?(.+)/)[1];\n\n      if (checkAllAliases(key, flags.arrays)) {\n        // array format = '--foo a b c'\n        i = eatArray(i, key, args);\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\n        // nargs format = '--foo a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        i = eatNargs(i, key, args);\n      } else {\n        next = args[i + 1];\n\n        if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n          setArg(key, next);\n          i++;\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next);\n          i++;\n        } else {\n          setArg(key, defaultValue(key));\n        }\n      } // dot-notation flag separated by '='.\n\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n      setArg(m[1], m[2]); // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n      next = args[i + 1];\n      key = arg.match(/^-(.\\..+)/)[1];\n\n      if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n        setArg(key, next);\n        i++;\n      } else {\n        setArg(key, defaultValue(key));\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('');\n      broken = false;\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3);\n          key = letters[j];\n\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f=a b c'\n            i = eatArray(i, key, args, value);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f=monkey washing cat'\n            i = eatNargs(i, key, args, value);\n          } else {\n            setArg(key, value);\n          }\n\n          broken = true;\n          break;\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next);\n          continue;\n        } // current letter is an alphabetic character and next value is a number\n\n\n        if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next);\n          broken = true;\n          break;\n        } else {\n          setArg(letters[j], defaultValue(letters[j]));\n        }\n      }\n\n      key = arg.slice(-1)[0];\n\n      if (!broken && key !== '-') {\n        if (checkAllAliases(key, flags.arrays)) {\n          // array format = '-f a b c'\n          i = eatArray(i, key, args);\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\n          // nargs format = '-f a b c'\n          // should be truthy even if: flags.nargs[key] === 0\n          i = eatNargs(i, key, args);\n        } else {\n          next = args[i + 1];\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      }\n    } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n      // single-digit boolean alias, e.g: xargs -0\n      key = arg.slice(1);\n      setArg(key, defaultValue(key));\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1);\n      break;\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i);\n      break;\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg));\n    }\n  } // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n\n\n  applyEnvVars(argv, true); // special case: check env vars that point to config file\n\n  applyEnvVars(argv, false);\n  setConfig(argv);\n  setConfigObjects();\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n  applyCoercions(argv);\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv); // for any counts either not in args or without an explicit default, set to 0\n\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n  }); // '--' defaults to undefined.\n\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key);\n  });\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key];\n    });\n  }\n\n  if (configuration['strip-aliased']) {\n    ;\n    [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n      }\n\n      delete argv[alias];\n    });\n  } // how many arguments should we consume, based\n  // on the nargs option?\n\n\n  function eatNargs(i, key, args, argAfterEqualSign) {\n    let ii;\n    let toEat = checkAllAliases(key, flags.nargs); // NaN has a special meaning for the array type, indicating that one or\n    // more values are expected.\n\n    toEat = isNaN(toEat) ? 1 : toEat;\n\n    if (toEat === 0) {\n      if (!isUndefined(argAfterEqualSign)) {\n        error = Error(__('Argument unexpected for: %s', key));\n      }\n\n      setArg(key, defaultValue(key));\n      return i;\n    }\n\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n\n    if (configuration['nargs-eats-options']) {\n      // classic behavior, yargs eats positional and dash arguments.\n      if (args.length - (i + 1) + available < toEat) {\n        error = Error(__('Not enough arguments following: %s', key));\n      }\n\n      available = toEat;\n    } else {\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\n      // and terminates when one is observed.\n      for (ii = i + 1; ii < args.length; ii++) {\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n      }\n\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n    }\n\n    let consumed = Math.min(available, toEat);\n\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n      setArg(key, argAfterEqualSign);\n      consumed--;\n    }\n\n    for (ii = i + 1; ii < consumed + i + 1; ii++) {\n      setArg(key, args[ii]);\n    }\n\n    return i + consumed;\n  } // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n\n\n  function eatArray(i, key, args, argAfterEqualSign) {\n    let argsToSet = [];\n    let next = argAfterEqualSign || args[i + 1]; // If both array and nargs are configured, enforce the nargs count:\n\n    const nargsCount = checkAllAliases(key, flags.nargs);\n\n    if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n      argsToSet.push(true);\n    } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults[key] !== undefined) {\n        const defVal = defaults[key];\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n      }\n    } else {\n      // value in --option=value is eaten as is\n      if (!isUndefined(argAfterEqualSign)) {\n        argsToSet.push(processValue(key, argAfterEqualSign));\n      }\n\n      for (let ii = i + 1; ii < args.length; ii++) {\n        if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && argsToSet.length >= nargsCount) break;\n        next = args[ii];\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n        i = ii;\n        argsToSet.push(processValue(key, next));\n      }\n    } // If both array and nargs are configured, create an error if less than\n    // nargs positionals were found. NaN has special meaning, indicating\n    // that at least one value is required (more are okay).\n\n\n    if (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0) {\n      error = Error(__('Not enough arguments following: %s', key));\n    }\n\n    setArg(key, argsToSet);\n    return i;\n  }\n\n  function setArg(key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      const alias = key.split('.').map(function (prop) {\n        return camelCase(prop);\n      }).join('.');\n      addNewAlias(key, alias);\n    }\n\n    const value = processValue(key, val);\n    const splitKey = key.split('.');\n    setKey(argv, splitKey, value); // handle populating aliases of the full key\n\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.');\n        setKey(argv, x, value);\n      });\n    } // handle populating aliases of the first element of the dot-notation key\n\n\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;\n      (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.'); // expand alias with nested objects in key\n\n        const a = [].concat(splitKey);\n        a.shift(); // nuke the old key.\n\n        x = x.concat(a); // populate alias only if is not already an alias of the full key\n        // (already populated above)\n\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\n          setKey(argv, x, value);\n        }\n      });\n    } // Set normalize getter and setter when key is in 'normalize' but isn't an array\n\n\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      const keys = [key].concat(flags.aliases[key] || []);\n      keys.forEach(function (key) {\n        Object.defineProperty(argvReturn, key, {\n          enumerable: true,\n\n          get() {\n            return val;\n          },\n\n          set(value) {\n            val = typeof value === 'string' ? path.normalize(value) : value;\n          }\n\n        });\n      });\n    }\n  }\n\n  function addNewAlias(key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias];\n      newAliases[alias] = true;\n    }\n\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key);\n    }\n  }\n\n  function processValue(key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0]) {\n      val = val.substring(1, val.length - 1);\n    } // handle parsing boolean arguments --foo=true --bar false.\n\n\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true';\n    }\n\n    let value = Array.isArray(val) ? val.map(function (v) {\n      return maybeCoerceNumber(key, v);\n    }) : maybeCoerceNumber(key, val); // increment a count given as arg (either no value or value parsed as boolean)\n\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment;\n    } // Set normalized value when key is in 'normalize' and in 'arrays'\n\n\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize);else value = path.normalize(val);\n    }\n\n    return value;\n  }\n\n  function maybeCoerceNumber(key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(value));\n      if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) value = Number(value);\n    }\n\n    return value;\n  } // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n\n\n  function setConfig(argv) {\n    const configLookup = Object.create(null); // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n    Object.keys(flags.configs).forEach(function (configKey) {\n      const configPath = argv[configKey] || configLookup[configKey];\n\n      if (configPath) {\n        try {\n          let config = null;\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath);\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath);\n            } catch (e) {\n              config = e;\n            }\n\n            if (config instanceof Error) {\n              error = config;\n              return;\n            }\n          } else {\n            config = require(resolvedConfigPath);\n          }\n\n          setConfigObject(config);\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n        }\n      }\n    });\n  } // set args from config object.\n  // it recursively checks nested objects.\n\n\n  function setConfigObject(config, prev) {\n    Object.keys(config).forEach(function (key) {\n      const value = config[key];\n      const fullKey = prev ? prev + '.' + key : key; // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey);\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n          setArg(fullKey, value);\n        }\n      }\n    });\n  } // set all config objects passed in opts\n\n\n  function setConfigObjects() {\n    if (typeof configObjects === 'undefined') return;\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject);\n    });\n  }\n\n  function applyEnvVars(argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return;\n    const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        const keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length);\n          }\n\n          return camelCase(key);\n        });\n\n        if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar]);\n        }\n      }\n    });\n  }\n\n  function applyCoercions(argv) {\n    let coerce;\n    const applied = new Set();\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.has(key)) {\n        // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions);\n\n        if (typeof coerce === 'function') {\n          try {\n            const value = maybeCoerceNumber(key, coerce(argv[key]));\n            [].concat(flags.aliases[key] || [], key).forEach(ali => {\n              applied.add(ali);\n              argv[ali] = value;\n            });\n          } catch (err) {\n            error = err;\n          }\n        }\n      }\n    });\n  }\n\n  function setPlaceholderKeys(argv) {\n    flags.keys.forEach(key => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return;\n      if (typeof argv[key] === 'undefined') argv[key] = undefined;\n    });\n    return argv;\n  }\n\n  function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key]);\n        if (canLog) defaulted[key] = true;\n        (aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return;\n          setKey(obj, x.split('.'), defaults[key]);\n        });\n      }\n    });\n  }\n\n  function hasKey(obj, keys) {\n    let o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key) {\n      o = o[key] || {};\n    });\n    const key = keys[keys.length - 1];\n    if (typeof o !== 'object') return false;else return key in o;\n  }\n\n  function setKey(obj, keys, value) {\n    let o = obj;\n    if (!configuration['dot-notation']) keys = [keys.join('.')];\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key);\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {};\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({});\n        } else {\n          o[key] = [o[key], {}];\n        } // we want to update the empty object at the end of the o[key] array, so set o to that object\n\n\n        o = o[key][o[key].length - 1];\n      } else {\n        o = o[key];\n      }\n    }); // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n\n    const key = sanitizeKey(keys[keys.length - 1]);\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n    const isValueArray = Array.isArray(value);\n    let duplicate = configuration['duplicate-arguments-array']; // nargs has higher priority than duplicate\n\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true;\n\n      if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n        o[key] = undefined;\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key]);\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value;\n      } else {\n        o[key] = o[key].concat([value]);\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value];\n    } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n      o[key] = [o[key], value];\n    } else {\n      o[key] = value;\n    }\n  } // extend the aliases list with inferred aliases.\n\n\n  function extendAliases(...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return;\n        flags.aliases[key] = [].concat(aliases[key] || []); // For \"--option-name\", also set argv.optionName\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            const c = camelCase(x);\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        }); // For \"--optionName\", also set argv['option-name']\n\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            const c = decamelize(x, '-');\n\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c);\n              newAliases[c] = true;\n            }\n          }\n        });\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y;\n          }));\n        });\n      });\n    });\n  } // return the 1st set flag for any of a key's aliases (or false if no flag set)\n\n\n  function checkAllAliases(key, flag) {\n    const toCheck = [].concat(flags.aliases[key] || [], key);\n    const keys = Object.keys(flag);\n    const setAlias = toCheck.find(key => keys.includes(key));\n    return setAlias ? flag[setAlias] : false;\n  }\n\n  function hasAnyFlag(key) {\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]));\n    return toCheck.some(function (flag) {\n      return Array.isArray(flag) ? flag.includes(key) : flag[key];\n    });\n  }\n\n  function hasFlagsMatching(arg, ...patterns) {\n    const toCheck = [].concat(...patterns);\n    return toCheck.some(function (pattern) {\n      const match = arg.match(pattern);\n      return match && hasAnyFlag(match[1]);\n    });\n  } // based on a simplified version of the short flag group parsing logic\n\n\n  function hasAllShortFlags(arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n      return false;\n    }\n\n    let hasAllFlags = true;\n    let next;\n    const letters = arg.slice(1).split('');\n\n    for (let j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2);\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false;\n        break;\n      }\n\n      if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n        break;\n      }\n    }\n\n    return hasAllFlags;\n  }\n\n  function isUnknownOptionAsArg(arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n  }\n\n  function isUnknownOption(arg) {\n    // ignore negative numbers\n    if (arg.match(negative)) {\n      return false;\n    } // if this is a short option group and all of them are configured, it isn't unknown\n\n\n    if (hasAllShortFlags(arg)) {\n      return false;\n    } // e.g. '--count=2'\n\n\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/; // e.g. '-a' or '--arg'\n\n    const normalFlag = /^-+([^=]+?)$/; // e.g. '-a-'\n\n    const flagEndingInHyphen = /^-+([^=]+?)-$/; // e.g. '-abc123'\n\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/; // e.g. '-a/usr/local'\n\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/; // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n  } // make a best effor to pick a default value\n  // for an option based on name and type.\n\n\n  function defaultValue(key) {\n    if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n      return defaults[key];\n    } else {\n      return defaultForType(guessType(key));\n    }\n  } // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n\n\n  function defaultForType(type) {\n    const def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    };\n    return def[type];\n  } // given a flag, enforce a default type.\n\n\n  function guessType(key) {\n    let type = 'boolean';\n    if (checkAllAliases(key, flags.strings)) type = 'string';else if (checkAllAliases(key, flags.numbers)) type = 'number';else if (checkAllAliases(key, flags.bools)) type = 'boolean';else if (checkAllAliases(key, flags.arrays)) type = 'array';\n    return type;\n  }\n\n  function isNumber(x) {\n    if (x === null || x === undefined) return false; // if loaded from config, may already be a number.\n\n    if (typeof x === 'number') return true; // hexadecimal.\n\n    if (/^0x[0-9a-f]+$/i.test(x)) return true; // don't treat 0123 as a number; as it drops the leading '0'.\n\n    if (x.length > 1 && x[0] === '0') return false;\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n  }\n\n  function isUndefined(num) {\n    return num === undefined;\n  } // check user configuration settings for inconsistencies\n\n\n  function checkConfiguration() {\n    // count keys should not be set as array/narg\n    Object.keys(flags.counts).find(key => {\n      if (checkAllAliases(key, flags.arrays)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n        return true;\n      } else if (checkAllAliases(key, flags.nargs)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n        return true;\n      }\n    });\n  }\n\n  return {\n    argv: Object.assign(argvReturn, argv),\n    error: error,\n    aliases: Object.assign({}, flags.aliases),\n    newAliases: Object.assign({}, newAliases),\n    defaulted: Object.assign({}, defaulted),\n    configuration: configuration\n  };\n} // if any aliases reference each other, we should\n// merge them together.\n\n\nfunction combineAliases(aliases) {\n  const aliasArrays = [];\n  const combined = Object.create(null);\n  let change = true; // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  }); // combine arrays until zero changes are\n  // made in an iteration.\n\n  while (change) {\n    change = false;\n\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  } // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    combined[aliasArray.pop()] = aliasArray;\n  });\n  return combined;\n} // this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\n\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction Parser(args, opts) {\n  const result = parse(args.slice(), opts);\n  return result.argv;\n} // parse arguments and return detailed\n// meta information, aliases, etc.\n\n\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts);\n}; // TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\n\n\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\n\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/ofeki/OneDrive/שולחן העבודה/ExamApp design ver/ExamsApp/react_client_exams_app/node_modules/yargs-parser/index.js"],"names":["camelCase","require","decamelize","path","tokenizeArgString","util","parse","args","opts","Object","assign","create","aliases","combineAliases","alias","configuration","defaults","default","configObjects","envPrefix","notFlagsOption","notFlagsArgv","newAliases","defaulted","__","format","flags","arrays","bools","strings","numbers","counts","normalize","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","array","filter","Boolean","forEach","opt","key","assignment","map","boolean","string","number","pop","push","count","narg","k","coerce","Array","isArray","config","extendAliases","error","checkConfiguration","notFlags","argv","_","argvReturn","i","length","arg","broken","letters","m","next","value","isUnknownOptionAsArg","match","checkAllAliases","eatArray","eatNargs","setArg","undefined","test","defaultValue","slice","split","j","maybeCoerceNumber","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","prop","join","argAfterEqualSign","ii","toEat","isNaN","isUndefined","Error","available","consumed","Math","min","argsToSet","nargsCount","defVal","processValue","val","addNewAlias","splitKey","setKey","x","a","shift","defineProperty","enumerable","get","set","substring","v","increment","shouldCoerceNumber","isNumber","Number","isSafeInteger","floor","configLookup","configKey","configPath","resolvedConfigPath","resolve","process","cwd","e","setConfigObject","ex","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","applied","Set","has","ali","add","err","indexOf","obj","canLog","o","index","sanitizeKey","isTypeArray","isValueArray","duplicate","c","y","flag","toCheck","setAlias","find","hasAnyFlag","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","num","aliasArrays","combined","change","intersect","splice","aliasArray","self","orig","Parser","result","detailed","module","exports"],"mappings":"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","sourcesContent":["const camelCase = require('camelcase')\r\nconst decamelize = require('decamelize')\r\nconst path = require('path')\r\nconst tokenizeArgString = require('./lib/tokenize-arg-string')\r\nconst util = require('util')\r\n\r\nfunction parse (args, opts) {\r\n  opts = Object.assign(Object.create(null), opts)\r\n  // allow a string argument to be passed in rather\r\n  // than an argv array.\r\n  args = tokenizeArgString(args)\r\n\r\n  // aliases might have transitive relationships, normalize this.\r\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias))\r\n  const configuration = Object.assign({\r\n    'boolean-negation': true,\r\n    'camel-case-expansion': true,\r\n    'combine-arrays': false,\r\n    'dot-notation': true,\r\n    'duplicate-arguments-array': true,\r\n    'flatten-duplicate-arrays': true,\r\n    'greedy-arrays': true,\r\n    'halt-at-non-option': false,\r\n    'nargs-eats-options': false,\r\n    'negation-prefix': 'no-',\r\n    'parse-numbers': true,\r\n    'populate--': false,\r\n    'set-placeholder-key': false,\r\n    'short-option-groups': true,\r\n    'strip-aliased': false,\r\n    'strip-dashed': false,\r\n    'unknown-options-as-args': false\r\n  }, opts.configuration)\r\n  const defaults = Object.assign(Object.create(null), opts.default)\r\n  const configObjects = opts.configObjects || []\r\n  const envPrefix = opts.envPrefix\r\n  const notFlagsOption = configuration['populate--']\r\n  const notFlagsArgv = notFlagsOption ? '--' : '_'\r\n  const newAliases = Object.create(null)\r\n  const defaulted = Object.create(null)\r\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\r\n  const __ = opts.__ || util.format\r\n  const flags = {\r\n    aliases: Object.create(null),\r\n    arrays: Object.create(null),\r\n    bools: Object.create(null),\r\n    strings: Object.create(null),\r\n    numbers: Object.create(null),\r\n    counts: Object.create(null),\r\n    normalize: Object.create(null),\r\n    configs: Object.create(null),\r\n    nargs: Object.create(null),\r\n    coercions: Object.create(null),\r\n    keys: []\r\n  }\r\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/\r\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\r\n\r\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\r\n    const key = opt.key || opt\r\n\r\n    // assign to flags[bools|strings|numbers]\r\n    const assignment = Object.keys(opt).map(function (key) {\r\n      return ({\r\n        boolean: 'bools',\r\n        string: 'strings',\r\n        number: 'numbers'\r\n      })[key]\r\n    }).filter(Boolean).pop()\r\n\r\n    // assign key to be coerced\r\n    if (assignment) {\r\n      flags[assignment][key] = true\r\n    }\r\n\r\n    flags.arrays[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\r\n    flags.bools[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\r\n    flags.strings[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\r\n    flags.numbers[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\r\n    flags.counts[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\r\n    flags.normalize[key] = true\r\n    flags.keys.push(key)\r\n  })\r\n\r\n  Object.keys(opts.narg || {}).forEach(function (k) {\r\n    flags.nargs[k] = opts.narg[k]\r\n    flags.keys.push(k)\r\n  })\r\n\r\n  Object.keys(opts.coerce || {}).forEach(function (k) {\r\n    flags.coercions[k] = opts.coerce[k]\r\n    flags.keys.push(k)\r\n  })\r\n\r\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\r\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\r\n      flags.configs[key] = true\r\n    })\r\n  } else {\r\n    Object.keys(opts.config || {}).forEach(function (k) {\r\n      flags.configs[k] = opts.config[k]\r\n    })\r\n  }\r\n\r\n  // create a lookup table that takes into account all\r\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\r\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\r\n\r\n  // apply default values to all aliases.\r\n  Object.keys(defaults).forEach(function (key) {\r\n    (flags.aliases[key] || []).forEach(function (alias) {\r\n      defaults[alias] = defaults[key]\r\n    })\r\n  })\r\n\r\n  let error = null\r\n  checkConfiguration()\r\n\r\n  let notFlags = []\r\n\r\n  const argv = Object.assign(Object.create(null), { _: [] })\r\n  // TODO(bcoe): for the first pass at removing object prototype  we didn't\r\n  // remove all prototypes from objects returned by this API, we might want\r\n  // to gradually move towards doing so.\r\n  const argvReturn = {}\r\n\r\n  for (let i = 0; i < args.length; i++) {\r\n    const arg = args[i]\r\n    let broken\r\n    let key\r\n    let letters\r\n    let m\r\n    let next\r\n    let value\r\n\r\n    // any unknown option (except for end-of-options, \"--\")\r\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\r\n      argv._.push(arg)\r\n    // -- separated by =\r\n    } else if (arg.match(/^--.+=/) || (\r\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\r\n    )) {\r\n      // Using [\\s\\S] instead of . because js doesn't support the\r\n      // 'dotall' regex modifier. See:\r\n      // http://stackoverflow.com/a/1068308/13216\r\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\r\n\r\n      // arrays format = '--f=a b c'\r\n      if (checkAllAliases(m[1], flags.arrays)) {\r\n        i = eatArray(i, m[1], args, m[2])\r\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\r\n        // nargs format = '--f=monkey washing cat'\r\n        i = eatNargs(i, m[1], args, m[2])\r\n      } else {\r\n        setArg(m[1], m[2])\r\n      }\r\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\r\n      key = arg.match(negatedBoolean)[1]\r\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false)\r\n\r\n    // -- separated by space.\r\n    } else if (arg.match(/^--.+/) || (\r\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\r\n    )) {\r\n      key = arg.match(/^--?(.+)/)[1]\r\n\r\n      if (checkAllAliases(key, flags.arrays)) {\r\n        // array format = '--foo a b c'\r\n        i = eatArray(i, key, args)\r\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\r\n        // nargs format = '--foo a b c'\r\n        // should be truthy even if: flags.nargs[key] === 0\r\n        i = eatNargs(i, key, args)\r\n      } else {\r\n        next = args[i + 1]\r\n\r\n        if (next !== undefined && (!next.match(/^-/) ||\r\n          next.match(negative)) &&\r\n          !checkAllAliases(key, flags.bools) &&\r\n          !checkAllAliases(key, flags.counts)) {\r\n          setArg(key, next)\r\n          i++\r\n        } else if (/^(true|false)$/.test(next)) {\r\n          setArg(key, next)\r\n          i++\r\n        } else {\r\n          setArg(key, defaultValue(key))\r\n        }\r\n      }\r\n\r\n    // dot-notation flag separated by '='.\r\n    } else if (arg.match(/^-.\\..+=/)) {\r\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\r\n      setArg(m[1], m[2])\r\n\r\n    // dot-notation flag separated by space.\r\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\r\n      next = args[i + 1]\r\n      key = arg.match(/^-(.\\..+)/)[1]\r\n\r\n      if (next !== undefined && !next.match(/^-/) &&\r\n        !checkAllAliases(key, flags.bools) &&\r\n        !checkAllAliases(key, flags.counts)) {\r\n        setArg(key, next)\r\n        i++\r\n      } else {\r\n        setArg(key, defaultValue(key))\r\n      }\r\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\r\n      letters = arg.slice(1, -1).split('')\r\n      broken = false\r\n\r\n      for (let j = 0; j < letters.length; j++) {\r\n        next = arg.slice(j + 2)\r\n\r\n        if (letters[j + 1] && letters[j + 1] === '=') {\r\n          value = arg.slice(j + 3)\r\n          key = letters[j]\r\n\r\n          if (checkAllAliases(key, flags.arrays)) {\r\n            // array format = '-f=a b c'\r\n            i = eatArray(i, key, args, value)\r\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\r\n            // nargs format = '-f=monkey washing cat'\r\n            i = eatNargs(i, key, args, value)\r\n          } else {\r\n            setArg(key, value)\r\n          }\r\n\r\n          broken = true\r\n          break\r\n        }\r\n\r\n        if (next === '-') {\r\n          setArg(letters[j], next)\r\n          continue\r\n        }\r\n\r\n        // current letter is an alphabetic character and next value is a number\r\n        if (/[A-Za-z]/.test(letters[j]) &&\r\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\r\n          setArg(letters[j], next)\r\n          broken = true\r\n          break\r\n        }\r\n\r\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\r\n          setArg(letters[j], next)\r\n          broken = true\r\n          break\r\n        } else {\r\n          setArg(letters[j], defaultValue(letters[j]))\r\n        }\r\n      }\r\n\r\n      key = arg.slice(-1)[0]\r\n\r\n      if (!broken && key !== '-') {\r\n        if (checkAllAliases(key, flags.arrays)) {\r\n          // array format = '-f a b c'\r\n          i = eatArray(i, key, args)\r\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\r\n          // nargs format = '-f a b c'\r\n          // should be truthy even if: flags.nargs[key] === 0\r\n          i = eatNargs(i, key, args)\r\n        } else {\r\n          next = args[i + 1]\r\n\r\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\r\n            next.match(negative)) &&\r\n            !checkAllAliases(key, flags.bools) &&\r\n            !checkAllAliases(key, flags.counts)) {\r\n            setArg(key, next)\r\n            i++\r\n          } else if (/^(true|false)$/.test(next)) {\r\n            setArg(key, next)\r\n            i++\r\n          } else {\r\n            setArg(key, defaultValue(key))\r\n          }\r\n        }\r\n      }\r\n    } else if (arg.match(/^-[0-9]$/) &&\r\n      arg.match(negative) &&\r\n      checkAllAliases(arg.slice(1), flags.bools)) {\r\n      // single-digit boolean alias, e.g: xargs -0\r\n      key = arg.slice(1)\r\n      setArg(key, defaultValue(key))\r\n    } else if (arg === '--') {\r\n      notFlags = args.slice(i + 1)\r\n      break\r\n    } else if (configuration['halt-at-non-option']) {\r\n      notFlags = args.slice(i)\r\n      break\r\n    } else {\r\n      argv._.push(maybeCoerceNumber('_', arg))\r\n    }\r\n  }\r\n\r\n  // order of precedence:\r\n  // 1. command line arg\r\n  // 2. value from env var\r\n  // 3. value from config file\r\n  // 4. value from config objects\r\n  // 5. configured default value\r\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\r\n  applyEnvVars(argv, false)\r\n  setConfig(argv)\r\n  setConfigObjects()\r\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true)\r\n  applyCoercions(argv)\r\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\r\n\r\n  // for any counts either not in args or without an explicit default, set to 0\r\n  Object.keys(flags.counts).forEach(function (key) {\r\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\r\n  })\r\n\r\n  // '--' defaults to undefined.\r\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\r\n  notFlags.forEach(function (key) {\r\n    argv[notFlagsArgv].push(key)\r\n  })\r\n\r\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\r\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\r\n      delete argv[key]\r\n    })\r\n  }\r\n\r\n  if (configuration['strip-aliased']) {\r\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\r\n      if (configuration['camel-case-expansion']) {\r\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\r\n      }\r\n\r\n      delete argv[alias]\r\n    })\r\n  }\r\n\r\n  // how many arguments should we consume, based\r\n  // on the nargs option?\r\n  function eatNargs (i, key, args, argAfterEqualSign) {\r\n    let ii\r\n    let toEat = checkAllAliases(key, flags.nargs)\r\n    // NaN has a special meaning for the array type, indicating that one or\r\n    // more values are expected.\r\n    toEat = isNaN(toEat) ? 1 : toEat\r\n\r\n    if (toEat === 0) {\r\n      if (!isUndefined(argAfterEqualSign)) {\r\n        error = Error(__('Argument unexpected for: %s', key))\r\n      }\r\n      setArg(key, defaultValue(key))\r\n      return i\r\n    }\r\n\r\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1\r\n    if (configuration['nargs-eats-options']) {\r\n      // classic behavior, yargs eats positional and dash arguments.\r\n      if (args.length - (i + 1) + available < toEat) {\r\n        error = Error(__('Not enough arguments following: %s', key))\r\n      }\r\n      available = toEat\r\n    } else {\r\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\r\n      // and terminates when one is observed.\r\n      for (ii = i + 1; ii < args.length; ii++) {\r\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++\r\n        else break\r\n      }\r\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\r\n    }\r\n\r\n    let consumed = Math.min(available, toEat)\r\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\r\n      setArg(key, argAfterEqualSign)\r\n      consumed--\r\n    }\r\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\r\n      setArg(key, args[ii])\r\n    }\r\n\r\n    return (i + consumed)\r\n  }\r\n\r\n  // if an option is an array, eat all non-hyphenated arguments\r\n  // following it... YUM!\r\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\r\n  function eatArray (i, key, args, argAfterEqualSign) {\r\n    let argsToSet = []\r\n    let next = argAfterEqualSign || args[i + 1]\r\n    // If both array and nargs are configured, enforce the nargs count:\r\n    const nargsCount = checkAllAliases(key, flags.nargs)\r\n\r\n    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\r\n      argsToSet.push(true)\r\n    } else if (isUndefined(next) ||\r\n        (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\r\n      // for keys without value ==> argsToSet remains an empty []\r\n      // set user default value, if available\r\n      if (defaults[key] !== undefined) {\r\n        const defVal = defaults[key]\r\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal]\r\n      }\r\n    } else {\r\n      // value in --option=value is eaten as is\r\n      if (!isUndefined(argAfterEqualSign)) {\r\n        argsToSet.push(processValue(key, argAfterEqualSign))\r\n      }\r\n      for (let ii = i + 1; ii < args.length; ii++) {\r\n        if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\r\n          (nargsCount && argsToSet.length >= nargsCount)) break\r\n        next = args[ii]\r\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break\r\n        i = ii\r\n        argsToSet.push(processValue(key, next))\r\n      }\r\n    }\r\n\r\n    // If both array and nargs are configured, create an error if less than\r\n    // nargs positionals were found. NaN has special meaning, indicating\r\n    // that at least one value is required (more are okay).\r\n    if ((nargsCount && argsToSet.length < nargsCount) ||\r\n        (isNaN(nargsCount) && argsToSet.length === 0)) {\r\n      error = Error(__('Not enough arguments following: %s', key))\r\n    }\r\n\r\n    setArg(key, argsToSet)\r\n    return i\r\n  }\r\n\r\n  function setArg (key, val) {\r\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\r\n      const alias = key.split('.').map(function (prop) {\r\n        return camelCase(prop)\r\n      }).join('.')\r\n      addNewAlias(key, alias)\r\n    }\r\n\r\n    const value = processValue(key, val)\r\n    const splitKey = key.split('.')\r\n    setKey(argv, splitKey, value)\r\n\r\n    // handle populating aliases of the full key\r\n    if (flags.aliases[key]) {\r\n      flags.aliases[key].forEach(function (x) {\r\n        x = x.split('.')\r\n        setKey(argv, x, value)\r\n      })\r\n    }\r\n\r\n    // handle populating aliases of the first element of the dot-notation key\r\n    if (splitKey.length > 1 && configuration['dot-notation']) {\r\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\r\n        x = x.split('.')\r\n\r\n        // expand alias with nested objects in key\r\n        const a = [].concat(splitKey)\r\n        a.shift() // nuke the old key.\r\n        x = x.concat(a)\r\n\r\n        // populate alias only if is not already an alias of the full key\r\n        // (already populated above)\r\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\r\n          setKey(argv, x, value)\r\n        }\r\n      })\r\n    }\r\n\r\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\r\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\r\n      const keys = [key].concat(flags.aliases[key] || [])\r\n      keys.forEach(function (key) {\r\n        Object.defineProperty(argvReturn, key, {\r\n          enumerable: true,\r\n          get () {\r\n            return val\r\n          },\r\n          set (value) {\r\n            val = typeof value === 'string' ? path.normalize(value) : value\r\n          }\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  function addNewAlias (key, alias) {\r\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\r\n      flags.aliases[key] = [alias]\r\n      newAliases[alias] = true\r\n    }\r\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\r\n      addNewAlias(alias, key)\r\n    }\r\n  }\r\n\r\n  function processValue (key, val) {\r\n    // strings may be quoted, clean this up as we assign values.\r\n    if (typeof val === 'string' &&\r\n      (val[0] === \"'\" || val[0] === '\"') &&\r\n      val[val.length - 1] === val[0]\r\n    ) {\r\n      val = val.substring(1, val.length - 1)\r\n    }\r\n\r\n    // handle parsing boolean arguments --foo=true --bar false.\r\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\r\n      if (typeof val === 'string') val = val === 'true'\r\n    }\r\n\r\n    let value = Array.isArray(val)\r\n      ? val.map(function (v) { return maybeCoerceNumber(key, v) })\r\n      : maybeCoerceNumber(key, val)\r\n\r\n    // increment a count given as arg (either no value or value parsed as boolean)\r\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\r\n      value = increment\r\n    }\r\n\r\n    // Set normalized value when key is in 'normalize' and in 'arrays'\r\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\r\n      if (Array.isArray(val)) value = val.map(path.normalize)\r\n      else value = path.normalize(val)\r\n    }\r\n    return value\r\n  }\r\n\r\n  function maybeCoerceNumber (key, value) {\r\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\r\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\r\n        Number.isSafeInteger(Math.floor(value))\r\n      )\r\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\r\n    }\r\n    return value\r\n  }\r\n\r\n  // set args from config.json file, this should be\r\n  // applied last so that defaults can be applied.\r\n  function setConfig (argv) {\r\n    const configLookup = Object.create(null)\r\n\r\n    // expand defaults/aliases, in-case any happen to reference\r\n    // the config.json file.\r\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\r\n\r\n    Object.keys(flags.configs).forEach(function (configKey) {\r\n      const configPath = argv[configKey] || configLookup[configKey]\r\n      if (configPath) {\r\n        try {\r\n          let config = null\r\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath)\r\n\r\n          if (typeof flags.configs[configKey] === 'function') {\r\n            try {\r\n              config = flags.configs[configKey](resolvedConfigPath)\r\n            } catch (e) {\r\n              config = e\r\n            }\r\n            if (config instanceof Error) {\r\n              error = config\r\n              return\r\n            }\r\n          } else {\r\n            config = require(resolvedConfigPath)\r\n          }\r\n\r\n          setConfigObject(config)\r\n        } catch (ex) {\r\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  // set args from config object.\r\n  // it recursively checks nested objects.\r\n  function setConfigObject (config, prev) {\r\n    Object.keys(config).forEach(function (key) {\r\n      const value = config[key]\r\n      const fullKey = prev ? prev + '.' + key : key\r\n\r\n      // if the value is an inner object and we have dot-notation\r\n      // enabled, treat inner objects in config the same as\r\n      // heavily nested dot notations (foo.bar.apple).\r\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\r\n        // if the value is an object but not an array, check nested object\r\n        setConfigObject(value, fullKey)\r\n      } else {\r\n        // setting arguments via CLI takes precedence over\r\n        // values within the config file.\r\n        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\r\n          setArg(fullKey, value)\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  // set all config objects passed in opts\r\n  function setConfigObjects () {\r\n    if (typeof configObjects === 'undefined') return\r\n    configObjects.forEach(function (configObject) {\r\n      setConfigObject(configObject)\r\n    })\r\n  }\r\n\r\n  function applyEnvVars (argv, configOnly) {\r\n    if (typeof envPrefix === 'undefined') return\r\n\r\n    const prefix = typeof envPrefix === 'string' ? envPrefix : ''\r\n    Object.keys(process.env).forEach(function (envVar) {\r\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\r\n        // get array of nested keys and convert them to camel case\r\n        const keys = envVar.split('__').map(function (key, i) {\r\n          if (i === 0) {\r\n            key = key.substring(prefix.length)\r\n          }\r\n          return camelCase(key)\r\n        })\r\n\r\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\r\n          setArg(keys.join('.'), process.env[envVar])\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  function applyCoercions (argv) {\r\n    let coerce\r\n    const applied = new Set()\r\n    Object.keys(argv).forEach(function (key) {\r\n      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\r\n        coerce = checkAllAliases(key, flags.coercions)\r\n        if (typeof coerce === 'function') {\r\n          try {\r\n            const value = maybeCoerceNumber(key, coerce(argv[key]))\r\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\r\n              applied.add(ali)\r\n              argv[ali] = value\r\n            })\r\n          } catch (err) {\r\n            error = err\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  function setPlaceholderKeys (argv) {\r\n    flags.keys.forEach((key) => {\r\n      // don't set placeholder keys for dot notation options 'foo.bar'.\r\n      if (~key.indexOf('.')) return\r\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\r\n    })\r\n    return argv\r\n  }\r\n\r\n  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {\r\n    Object.keys(defaults).forEach(function (key) {\r\n      if (!hasKey(obj, key.split('.'))) {\r\n        setKey(obj, key.split('.'), defaults[key])\r\n        if (canLog) defaulted[key] = true\r\n\r\n        ;(aliases[key] || []).forEach(function (x) {\r\n          if (hasKey(obj, x.split('.'))) return\r\n          setKey(obj, x.split('.'), defaults[key])\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  function hasKey (obj, keys) {\r\n    let o = obj\r\n\r\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\r\n\r\n    keys.slice(0, -1).forEach(function (key) {\r\n      o = (o[key] || {})\r\n    })\r\n\r\n    const key = keys[keys.length - 1]\r\n\r\n    if (typeof o !== 'object') return false\r\n    else return key in o\r\n  }\r\n\r\n  function setKey (obj, keys, value) {\r\n    let o = obj\r\n\r\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\r\n\r\n    keys.slice(0, -1).forEach(function (key, index) {\r\n      // TODO(bcoe): in the next major version of yargs, switch to\r\n      // Object.create(null) for dot notation:\r\n      key = sanitizeKey(key)\r\n\r\n      if (typeof o === 'object' && o[key] === undefined) {\r\n        o[key] = {}\r\n      }\r\n\r\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\r\n        // ensure that o[key] is an array, and that the last item is an empty object.\r\n        if (Array.isArray(o[key])) {\r\n          o[key].push({})\r\n        } else {\r\n          o[key] = [o[key], {}]\r\n        }\r\n\r\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\r\n        o = o[key][o[key].length - 1]\r\n      } else {\r\n        o = o[key]\r\n      }\r\n    })\r\n\r\n    // TODO(bcoe): in the next major version of yargs, switch to\r\n    // Object.create(null) for dot notation:\r\n    const key = sanitizeKey(keys[keys.length - 1])\r\n\r\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\r\n    const isValueArray = Array.isArray(value)\r\n    let duplicate = configuration['duplicate-arguments-array']\r\n\r\n    // nargs has higher priority than duplicate\r\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\r\n      duplicate = true\r\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\r\n        o[key] = undefined\r\n      }\r\n    }\r\n\r\n    if (value === increment) {\r\n      o[key] = increment(o[key])\r\n    } else if (Array.isArray(o[key])) {\r\n      if (duplicate && isTypeArray && isValueArray) {\r\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\r\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\r\n        o[key] = value\r\n      } else {\r\n        o[key] = o[key].concat([value])\r\n      }\r\n    } else if (o[key] === undefined && isTypeArray) {\r\n      o[key] = isValueArray ? value : [value]\r\n    } else if (duplicate && !(\r\n      o[key] === undefined ||\r\n        checkAllAliases(key, flags.counts) ||\r\n        checkAllAliases(key, flags.bools)\r\n    )) {\r\n      o[key] = [o[key], value]\r\n    } else {\r\n      o[key] = value\r\n    }\r\n  }\r\n\r\n  // extend the aliases list with inferred aliases.\r\n  function extendAliases (...args) {\r\n    args.forEach(function (obj) {\r\n      Object.keys(obj || {}).forEach(function (key) {\r\n        // short-circuit if we've already added a key\r\n        // to the aliases array, for example it might\r\n        // exist in both 'opts.default' and 'opts.key'.\r\n        if (flags.aliases[key]) return\r\n\r\n        flags.aliases[key] = [].concat(aliases[key] || [])\r\n        // For \"--option-name\", also set argv.optionName\r\n        flags.aliases[key].concat(key).forEach(function (x) {\r\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\r\n            const c = camelCase(x)\r\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\r\n              flags.aliases[key].push(c)\r\n              newAliases[c] = true\r\n            }\r\n          }\r\n        })\r\n        // For \"--optionName\", also set argv['option-name']\r\n        flags.aliases[key].concat(key).forEach(function (x) {\r\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\r\n            const c = decamelize(x, '-')\r\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\r\n              flags.aliases[key].push(c)\r\n              newAliases[c] = true\r\n            }\r\n          }\r\n        })\r\n        flags.aliases[key].forEach(function (x) {\r\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\r\n            return x !== y\r\n          }))\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  // return the 1st set flag for any of a key's aliases (or false if no flag set)\r\n  function checkAllAliases (key, flag) {\r\n    const toCheck = [].concat(flags.aliases[key] || [], key)\r\n    const keys = Object.keys(flag)\r\n    const setAlias = toCheck.find(key => keys.includes(key))\r\n    return setAlias ? flag[setAlias] : false\r\n  }\r\n\r\n  function hasAnyFlag (key) {\r\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]))\r\n    return toCheck.some(function (flag) {\r\n      return Array.isArray(flag) ? flag.includes(key) : flag[key]\r\n    })\r\n  }\r\n\r\n  function hasFlagsMatching (arg, ...patterns) {\r\n    const toCheck = [].concat(...patterns)\r\n    return toCheck.some(function (pattern) {\r\n      const match = arg.match(pattern)\r\n      return match && hasAnyFlag(match[1])\r\n    })\r\n  }\r\n\r\n  // based on a simplified version of the short flag group parsing logic\r\n  function hasAllShortFlags (arg) {\r\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\r\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }\r\n    let hasAllFlags = true\r\n    let next\r\n    const letters = arg.slice(1).split('')\r\n    for (let j = 0; j < letters.length; j++) {\r\n      next = arg.slice(j + 2)\r\n\r\n      if (!hasAnyFlag(letters[j])) {\r\n        hasAllFlags = false\r\n        break\r\n      }\r\n\r\n      if ((letters[j + 1] && letters[j + 1] === '=') ||\r\n        next === '-' ||\r\n        (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\r\n        (letters[j + 1] && letters[j + 1].match(/\\W/))) {\r\n        break\r\n      }\r\n    }\r\n    return hasAllFlags\r\n  }\r\n\r\n  function isUnknownOptionAsArg (arg) {\r\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg)\r\n  }\r\n\r\n  function isUnknownOption (arg) {\r\n    // ignore negative numbers\r\n    if (arg.match(negative)) { return false }\r\n    // if this is a short option group and all of them are configured, it isn't unknown\r\n    if (hasAllShortFlags(arg)) { return false }\r\n    // e.g. '--count=2'\r\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/\r\n    // e.g. '-a' or '--arg'\r\n    const normalFlag = /^-+([^=]+?)$/\r\n    // e.g. '-a-'\r\n    const flagEndingInHyphen = /^-+([^=]+?)-$/\r\n    // e.g. '-abc123'\r\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/\r\n    // e.g. '-a/usr/local'\r\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/\r\n    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\r\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)\r\n  }\r\n\r\n  // make a best effor to pick a default value\r\n  // for an option based on name and type.\r\n  function defaultValue (key) {\r\n    if (!checkAllAliases(key, flags.bools) &&\r\n        !checkAllAliases(key, flags.counts) &&\r\n        `${key}` in defaults) {\r\n      return defaults[key]\r\n    } else {\r\n      return defaultForType(guessType(key))\r\n    }\r\n  }\r\n\r\n  // return a default value, given the type of a flag.,\r\n  // e.g., key of type 'string' will default to '', rather than 'true'.\r\n  function defaultForType (type) {\r\n    const def = {\r\n      boolean: true,\r\n      string: '',\r\n      number: undefined,\r\n      array: []\r\n    }\r\n\r\n    return def[type]\r\n  }\r\n\r\n  // given a flag, enforce a default type.\r\n  function guessType (key) {\r\n    let type = 'boolean'\r\n    if (checkAllAliases(key, flags.strings)) type = 'string'\r\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\r\n    else if (checkAllAliases(key, flags.bools)) type = 'boolean'\r\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\r\n    return type\r\n  }\r\n\r\n  function isNumber (x) {\r\n    if (x === null || x === undefined) return false\r\n    // if loaded from config, may already be a number.\r\n    if (typeof x === 'number') return true\r\n    // hexadecimal.\r\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\r\n    // don't treat 0123 as a number; as it drops the leading '0'.\r\n    if (x.length > 1 && x[0] === '0') return false\r\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\r\n  }\r\n\r\n  function isUndefined (num) {\r\n    return num === undefined\r\n  }\r\n\r\n  // check user configuration settings for inconsistencies\r\n  function checkConfiguration () {\r\n    // count keys should not be set as array/narg\r\n    Object.keys(flags.counts).find(key => {\r\n      if (checkAllAliases(key, flags.arrays)) {\r\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key))\r\n        return true\r\n      } else if (checkAllAliases(key, flags.nargs)) {\r\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key))\r\n        return true\r\n      }\r\n    })\r\n  }\r\n\r\n  return {\r\n    argv: Object.assign(argvReturn, argv),\r\n    error: error,\r\n    aliases: Object.assign({}, flags.aliases),\r\n    newAliases: Object.assign({}, newAliases),\r\n    defaulted: Object.assign({}, defaulted),\r\n    configuration: configuration\r\n  }\r\n}\r\n\r\n// if any aliases reference each other, we should\r\n// merge them together.\r\nfunction combineAliases (aliases) {\r\n  const aliasArrays = []\r\n  const combined = Object.create(null)\r\n  let change = true\r\n\r\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\r\n  // a simple array ['key', 'alias1', 'alias2']\r\n  Object.keys(aliases).forEach(function (key) {\r\n    aliasArrays.push(\r\n      [].concat(aliases[key], key)\r\n    )\r\n  })\r\n\r\n  // combine arrays until zero changes are\r\n  // made in an iteration.\r\n  while (change) {\r\n    change = false\r\n    for (let i = 0; i < aliasArrays.length; i++) {\r\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\r\n        const intersect = aliasArrays[i].filter(function (v) {\r\n          return aliasArrays[ii].indexOf(v) !== -1\r\n        })\r\n\r\n        if (intersect.length) {\r\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\r\n          aliasArrays.splice(ii, 1)\r\n          change = true\r\n          break\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // map arrays back to the hash-lookup (de-dupe while\r\n  // we're at it).\r\n  aliasArrays.forEach(function (aliasArray) {\r\n    aliasArray = aliasArray.filter(function (v, i, self) {\r\n      return self.indexOf(v) === i\r\n    })\r\n    combined[aliasArray.pop()] = aliasArray\r\n  })\r\n\r\n  return combined\r\n}\r\n\r\n// this function should only be called when a count is given as an arg\r\n// it is NOT called to set a default value\r\n// thus we can start the count at 1 instead of 0\r\nfunction increment (orig) {\r\n  return orig !== undefined ? orig + 1 : 1\r\n}\r\n\r\nfunction Parser (args, opts) {\r\n  const result = parse(args.slice(), opts)\r\n  return result.argv\r\n}\r\n\r\n// parse arguments and return detailed\r\n// meta information, aliases, etc.\r\nParser.detailed = function (args, opts) {\r\n  return parse(args.slice(), opts)\r\n}\r\n\r\n// TODO(bcoe): in the next major version of yargs, switch to\r\n// Object.create(null) for dot notation:\r\nfunction sanitizeKey (key) {\r\n  if (key === '__proto__') return '___proto___'\r\n  return key\r\n}\r\n\r\nmodule.exports = Parser\r\n"]},"metadata":{},"sourceType":"script"}