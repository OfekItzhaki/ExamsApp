{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.completion = void 0;\n\nconst command_1 = require(\"./command\");\n\nconst templates = require(\"./completion-templates\");\n\nconst is_promise_1 = require(\"./is-promise\");\n\nconst parse_command_1 = require(\"./parse-command\");\n\nconst path = require(\"path\");\n\nconst common_types_1 = require(\"./common-types\"); // add bash completions to your\n//  yargs-powered applications.\n\n\nfunction completion(yargs, usage, command) {\n  const self = {\n    completionKey: 'get-yargs-completions'\n  };\n  let aliases;\n\n  self.setParsed = function setParsed(parsed) {\n    aliases = parsed.aliases;\n  };\n\n  const zshShell = process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1 || process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf('zsh') !== -1; // get a list of completion commands.\n  // 'args' is the array of strings from the line to be completed\n\n  self.getCompletion = function getCompletion(args, done) {\n    const completions = [];\n    const current = args.length ? args[args.length - 1] : '';\n    const argv = yargs.parse(args, true);\n    const parentCommands = yargs.getContext().commands; // a custom completion function can be provided\n    // to completion().\n\n    function runCompletionFunction(argv) {\n      common_types_1.assertNotStrictEqual(completionFunction, null);\n\n      if (isSyncCompletionFunction(completionFunction)) {\n        const result = completionFunction(current, argv); // promise based completion function.\n\n        if (is_promise_1.isPromise(result)) {\n          return result.then(list => {\n            process.nextTick(() => {\n              done(list);\n            });\n          }).catch(err => {\n            process.nextTick(() => {\n              throw err;\n            });\n          });\n        } // synchronous completion function.\n\n\n        return done(result);\n      } else {\n        // asynchronous completion function\n        return completionFunction(current, argv, completions => {\n          done(completions);\n        });\n      }\n    }\n\n    if (completionFunction) {\n      return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\n    }\n\n    const handlers = command.getCommandHandlers();\n\n    for (let i = 0, ii = args.length; i < ii; ++i) {\n      if (handlers[args[i]] && handlers[args[i]].builder) {\n        const builder = handlers[args[i]].builder;\n\n        if (command_1.isCommandBuilderCallback(builder)) {\n          const y = yargs.reset();\n          builder(y);\n          return y.argv;\n        }\n      }\n    }\n\n    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n      usage.getCommands().forEach(usageCommand => {\n        const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;\n\n        if (args.indexOf(commandName) === -1) {\n          if (!zshShell) {\n            completions.push(commandName);\n          } else {\n            const desc = usageCommand[1] || '';\n            completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n          }\n        }\n      });\n    }\n\n    if (current.match(/^-/) || current === '' && completions.length === 0) {\n      const descs = usage.getDescriptions();\n      const options = yargs.getOptions();\n      Object.keys(options.key).forEach(key => {\n        const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key); // If the key and its aliases aren't in 'args', add the key to 'completions'\n\n        let keyAndAliases = [key].concat(aliases[key] || []);\n        if (negable) keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n\n        function completeOptionKey(key) {\n          const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n\n          if (notInArgs) {\n            const startsByTwoDashes = s => /^--/.test(s);\n\n            const isShortOption = s => /^[^0-9]$/.test(s);\n\n            const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n\n            if (!zshShell) {\n              completions.push(dashes + key);\n            } else {\n              const desc = descs[key] || '';\n              completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n            }\n          }\n        }\n\n        completeOptionKey(key);\n        if (negable && !!options.default[key]) completeOptionKey(`no-${key}`);\n      });\n    }\n\n    done(completions);\n  }; // generate the completion script to add to your .bashrc.\n\n\n  self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n    let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\n    const name = path.basename($0); // add ./to applications not yet installed as bin.\n\n    if ($0.match(/\\.js$/)) $0 = `./${$0}`;\n    script = script.replace(/{{app_name}}/g, name);\n    script = script.replace(/{{completion_command}}/g, cmd);\n    return script.replace(/{{app_path}}/g, $0);\n  }; // register a function to perform your own custom\n  // completions., this function can be either\n  // synchrnous or asynchronous.\n\n\n  let completionFunction = null;\n\n  self.registerFunction = fn => {\n    completionFunction = fn;\n  };\n\n  return self;\n}\n\nexports.completion = completion;\n\nfunction isSyncCompletionFunction(completionFunction) {\n  return completionFunction.length < 3;\n}","map":{"version":3,"sources":["C:/Users/ofeki/OneDrive/שולחן העבודה/ExamApp design ver/ExamsApp/react_client_exams_app/node_modules/yargs/build/lib/completion.js"],"names":["Object","defineProperty","exports","value","completion","command_1","require","templates","is_promise_1","parse_command_1","path","common_types_1","yargs","usage","command","self","completionKey","aliases","setParsed","parsed","zshShell","process","env","SHELL","indexOf","ZSH_NAME","getCompletion","args","done","completions","current","length","argv","parse","parentCommands","getContext","commands","runCompletionFunction","assertNotStrictEqual","completionFunction","isSyncCompletionFunction","result","isPromise","then","list","nextTick","catch","err","handlers","getCommandHandlers","i","ii","builder","isCommandBuilderCallback","y","reset","match","getCommands","forEach","usageCommand","commandName","parseCommand","cmd","push","desc","replace","descs","getDescriptions","options","getOptions","keys","key","negable","configuration","boolean","includes","keyAndAliases","concat","map","completeOptionKey","notInArgs","every","val","startsByTwoDashes","s","test","isShortOption","dashes","default","generateCompletionScript","$0","script","completionZshTemplate","completionShTemplate","name","basename","registerFunction","fn"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.completion = void 0;\r\nconst command_1 = require(\"./command\");\r\nconst templates = require(\"./completion-templates\");\r\nconst is_promise_1 = require(\"./is-promise\");\r\nconst parse_command_1 = require(\"./parse-command\");\r\nconst path = require(\"path\");\r\nconst common_types_1 = require(\"./common-types\");\r\n// add bash completions to your\r\n//  yargs-powered applications.\r\nfunction completion(yargs, usage, command) {\r\n    const self = {\r\n        completionKey: 'get-yargs-completions'\r\n    };\r\n    let aliases;\r\n    self.setParsed = function setParsed(parsed) {\r\n        aliases = parsed.aliases;\r\n    };\r\n    const zshShell = (process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1) ||\r\n        (process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf('zsh') !== -1);\r\n    // get a list of completion commands.\r\n    // 'args' is the array of strings from the line to be completed\r\n    self.getCompletion = function getCompletion(args, done) {\r\n        const completions = [];\r\n        const current = args.length ? args[args.length - 1] : '';\r\n        const argv = yargs.parse(args, true);\r\n        const parentCommands = yargs.getContext().commands;\r\n        // a custom completion function can be provided\r\n        // to completion().\r\n        function runCompletionFunction(argv) {\r\n            common_types_1.assertNotStrictEqual(completionFunction, null);\r\n            if (isSyncCompletionFunction(completionFunction)) {\r\n                const result = completionFunction(current, argv);\r\n                // promise based completion function.\r\n                if (is_promise_1.isPromise(result)) {\r\n                    return result.then((list) => {\r\n                        process.nextTick(() => { done(list); });\r\n                    }).catch((err) => {\r\n                        process.nextTick(() => { throw err; });\r\n                    });\r\n                }\r\n                // synchronous completion function.\r\n                return done(result);\r\n            }\r\n            else {\r\n                // asynchronous completion function\r\n                return completionFunction(current, argv, (completions) => {\r\n                    done(completions);\r\n                });\r\n            }\r\n        }\r\n        if (completionFunction) {\r\n            return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\r\n        }\r\n        const handlers = command.getCommandHandlers();\r\n        for (let i = 0, ii = args.length; i < ii; ++i) {\r\n            if (handlers[args[i]] && handlers[args[i]].builder) {\r\n                const builder = handlers[args[i]].builder;\r\n                if (command_1.isCommandBuilderCallback(builder)) {\r\n                    const y = yargs.reset();\r\n                    builder(y);\r\n                    return y.argv;\r\n                }\r\n            }\r\n        }\r\n        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\r\n            usage.getCommands().forEach((usageCommand) => {\r\n                const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;\r\n                if (args.indexOf(commandName) === -1) {\r\n                    if (!zshShell) {\r\n                        completions.push(commandName);\r\n                    }\r\n                    else {\r\n                        const desc = usageCommand[1] || '';\r\n                        completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        if (current.match(/^-/) || (current === '' && completions.length === 0)) {\r\n            const descs = usage.getDescriptions();\r\n            const options = yargs.getOptions();\r\n            Object.keys(options.key).forEach((key) => {\r\n                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);\r\n                // If the key and its aliases aren't in 'args', add the key to 'completions'\r\n                let keyAndAliases = [key].concat(aliases[key] || []);\r\n                if (negable)\r\n                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\r\n                function completeOptionKey(key) {\r\n                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\r\n                    if (notInArgs) {\r\n                        const startsByTwoDashes = (s) => /^--/.test(s);\r\n                        const isShortOption = (s) => /^[^0-9]$/.test(s);\r\n                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\r\n                        if (!zshShell) {\r\n                            completions.push(dashes + key);\r\n                        }\r\n                        else {\r\n                            const desc = descs[key] || '';\r\n                            completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\r\n                        }\r\n                    }\r\n                }\r\n                completeOptionKey(key);\r\n                if (negable && !!options.default[key])\r\n                    completeOptionKey(`no-${key}`);\r\n            });\r\n        }\r\n        done(completions);\r\n    };\r\n    // generate the completion script to add to your .bashrc.\r\n    self.generateCompletionScript = function generateCompletionScript($0, cmd) {\r\n        let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\r\n        const name = path.basename($0);\r\n        // add ./to applications not yet installed as bin.\r\n        if ($0.match(/\\.js$/))\r\n            $0 = `./${$0}`;\r\n        script = script.replace(/{{app_name}}/g, name);\r\n        script = script.replace(/{{completion_command}}/g, cmd);\r\n        return script.replace(/{{app_path}}/g, $0);\r\n    };\r\n    // register a function to perform your own custom\r\n    // completions., this function can be either\r\n    // synchrnous or asynchronous.\r\n    let completionFunction = null;\r\n    self.registerFunction = (fn) => {\r\n        completionFunction = fn;\r\n    };\r\n    return self;\r\n}\r\nexports.completion = completion;\r\nfunction isSyncCompletionFunction(completionFunction) {\r\n    return completionFunction.length < 3;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}