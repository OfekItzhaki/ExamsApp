{"ast":null,"code":"'use strict';\n\nvar fs = require('fs'),\n    join = require('path').join,\n    resolve = require('path').resolve,\n    dirname = require('path').dirname,\n    defaultOptions = {\n  extensions: ['js', 'json', 'coffee'],\n  recurse: true,\n  rename: function (name) {\n    return name;\n  },\n  visit: function (obj) {\n    return obj;\n  }\n};\n\nfunction checkFileInclusion(path, filename, options) {\n  return (// verify file has valid extension\n    new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) && // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {}; // path is optional\n\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  } // default options\n\n\n  options = options || {};\n\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  } // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n\n\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path); // get the path of each file in specified directory, append to current tree node, recurse\n\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n        files,\n        key,\n        obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options); // exclude empty directories\n\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;","map":{"version":3,"sources":["C:/Users/ofeki/OneDrive/שולחן העבודה/ExamApp design ver/ExamsApp/react_client_exams_app/node_modules/require-directory/index.js"],"names":["fs","require","join","resolve","dirname","defaultOptions","extensions","recurse","rename","name","visit","obj","checkFileInclusion","path","filename","options","RegExp","test","include","exclude","requireDirectory","m","retval","prop","readdirSync","forEach","joined","files","key","statSync","isDirectory","Object","keys","length","substring","lastIndexOf","module","exports","defaults"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar fs = require('fs'),\r\n  join = require('path').join,\r\n  resolve = require('path').resolve,\r\n  dirname = require('path').dirname,\r\n  defaultOptions = {\r\n    extensions: ['js', 'json', 'coffee'],\r\n    recurse: true,\r\n    rename: function (name) {\r\n      return name;\r\n    },\r\n    visit: function (obj) {\r\n      return obj;\r\n    }\r\n  };\r\n\r\nfunction checkFileInclusion(path, filename, options) {\r\n  return (\r\n    // verify file has valid extension\r\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\r\n\r\n    // if options.include is a RegExp, evaluate it and make sure the path passes\r\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\r\n\r\n    // if options.include is a function, evaluate it and make sure the path passes\r\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\r\n\r\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\r\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\r\n\r\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\r\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\r\n  );\r\n}\r\n\r\nfunction requireDirectory(m, path, options) {\r\n  var retval = {};\r\n\r\n  // path is optional\r\n  if (path && !options && typeof path !== 'string') {\r\n    options = path;\r\n    path = null;\r\n  }\r\n\r\n  // default options\r\n  options = options || {};\r\n  for (var prop in defaultOptions) {\r\n    if (typeof options[prop] === 'undefined') {\r\n      options[prop] = defaultOptions[prop];\r\n    }\r\n  }\r\n\r\n  // if no path was passed in, assume the equivelant of __dirname from caller\r\n  // otherwise, resolve path relative to the equivalent of __dirname\r\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\r\n\r\n  // get the path of each file in specified directory, append to current tree node, recurse\r\n  fs.readdirSync(path).forEach(function (filename) {\r\n    var joined = join(path, filename),\r\n      files,\r\n      key,\r\n      obj;\r\n\r\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\r\n      // this node is a directory; recurse\r\n      files = requireDirectory(m, joined, options);\r\n      // exclude empty directories\r\n      if (Object.keys(files).length) {\r\n        retval[options.rename(filename, joined, filename)] = files;\r\n      }\r\n    } else {\r\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\r\n        // hash node key shouldn't include file extension\r\n        key = filename.substring(0, filename.lastIndexOf('.'));\r\n        obj = m.require(joined);\r\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\r\n      }\r\n    }\r\n  });\r\n\r\n  return retval;\r\n}\r\n\r\nmodule.exports = requireDirectory;\r\nmodule.exports.defaults = defaultOptions;\r\n"]},"metadata":{},"sourceType":"script"}